/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       matth                                                     */
/*    Created:      7/26/2023, 10:46:51 PM                                    */
/*    Description:  V5 project                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/
#include "vex.h"
#include "math.h"
#include "iostream"
#include <list>
#include <chrono>
#include <vector>

using namespace vex;

// A global instance of competition
competition Competition;

// constants used for physics and motion
const double TRACKWIDTH = 11.515;
const double PI = 3.1415;
const double G = -386.1; // 9.81 m/s but in inches/second^2
const double WHEEL_WIDTH = 4;
const double DRIVE_WHEEL_GEAR_RATIO = 5;
const double ARM_WHEEL_GEAR_RATIO = 5;
const double SHOOTER_WHEEL_GEAR_RATIO = 7;
const double ARM_MOTOR_STRIKE_ANGLE = -35;
const double SHOOTER_SPEED_MULTIPLIER = 1.295; // constant to multiply shooter motor rotation rate by after calculating its speed from equations, to account for error

class vector3 { // vectors in a more physical sense than c++'s default vectors

  public:

  double x;
  double y;
  double z;

  vector3(double x0, double y0, double z0) {
    x = x0;
    y = y0;
    z = z0;
  }

  vector3 difference(vector3 v) {
    return vector3(x-v.x, y-v.y, z-v.z);
  }

  double magnitude() {
    return sqrtf(x*x + y*y + z*z);
  }

  vector3 add(vector3 v) {
    return vector3(x+v.x, y+v.y, z+v.z);
  }

  void mirror(int playingSide) {
    x *= playingSide;
  }
};

class Detection {
  public:
  int centerX;
  int centerY;
  int width;
  int height;
  int color;
  Detection(int x, int y, int w, int h, int c) {
    centerX = x;
    centerY = y;
    width = w;
    height = h;
    color = c;
  }
  Detection() {
    centerX = 0;
    centerY = 0;
    width = 0;
    height = 0;
    color = 0;
  }
};

// constant for the positions of key points, relative to the recalibration position
int PLAYING_SIDE = 1; // -1 is left, 1 is right
bool inTeleopPeriod = false;
const int TARGET_CENTER_AND_WAIT = -1;
const int TARGET_RED_HOOP = 0;
const int TARGET_BLUE_HOOP = 1;
const int TARGET_CENTER_HOOP = 2;
const int TARGET_YELLOW_BALL_HOLDER = 3;
// Positions of various targets.
// Vectors are in (forward, right, up) format.
// All court-object position vectors are relative to the centerline of the court, touching the back end.
vector3 RED_HOOP_POSITION = vector3(74, 39.5, 27.5);
vector3 BLUE_HOOP_POSITION = vector3(74, 24, 17);
vector3 CENTER_HOOP_POSITION = vector3(74, 0, 26);
vector3 YELLOW_BALL_HOLDER_POSITION = vector3(74, 39.5, 10);
//
const vector3 TURRET_GIMBAL_POSITION = vector3(-0.2, 0, 1);
const vector3 CAMERA_RELATIVE_TO_TURRET_GIMBAL_POSITION = vector3(5, 0, 1); 

// constant for aiming
// For ball shooting; the point along the trajectory that we want to be at by the time we enter the hoop.
// 0.5 is at the vertex, lower is sooner (travelling up when it enters the hoop), higher is later (travelling down when it enters the hoop).
const double TARGET_POINT_ALONG_TRAJECTORY = 0.6;

// constants used for P-controller gain and other guidance

const double TURNING_GAIN_FINE = -0.3;
const double TURNING_GAIN_BROAD = -0.5;
const double COORDINATE_GUIDANCE_TURNING_GAIN = 0.3;
const double COORDINATE_GUIDANCE_DISTANCE_GAIN = 10;
const double MAX_DISTANCE_FROM_TARGET_NARROW = 1; // distance goal when driving to an objective
const double MAX_DISTANCE_FROM_TARGET_BROAD = 5; // acceptable distance when deciding whether to drive to an objective
const double MAX_ANGLE_FROM_TARGET = 1;
const double BALL_GRAB_DISTANCE = 6;

// A global instance of vex::brain used for printing to the V5 brain screen
vex::brain Brain;

// setting motors
motor motorLeft = motor(PORT1, ratio18_1, false);
motor motorRight = motor(PORT10, ratio18_1, true);
motor motorShooterL = motor(PORT11, ratio18_1, false);
motor motorShooterR = motor(PORT12, ratio18_1, true);
motor motorArm = motor(PORT8, ratio18_1, false);
motor motorPusher = motor(PORT13, ratio18_1, false);

// setting inertial
inertial IMU = inertial(PORT3);

// setting camera color signatures and making a constant to be able to refer to color signatures by the object they detect rather than their signature number
const int RED_BALL = 1;
const int BLUE_BALL = 2;
const int YELLOW_BALL = 3;
const int RED_HOOP = 4;
//const int BLUE_HOOP = 5;
const int GREEN_INDICATOR = 6;
const int YELLOW_INDICATOR = 7;
vex::vision::signature RED_BALL_SIG = vex::vision::signature(1, 10049, 11513, 10781, -425, 1, -212, 4.1, 0);
vex::vision::signature BLUE_BALL_SIG = vex::vision::signature(2, -2427, -1747, -2087, 10357, 12053, 11205, 5, 0);
vex::vision::signature YELLOW_BALL_SIG = vex::vision::signature(3, 2109, 2857, 2483, -3791, -3283, -3537, 4.7, 0);
vex::vision::signature RED_HOOP_SIG = vex::vision::signature(4, 7157, 7819, 7488, -1105, -373, -739, 11, 0);
vex::vision::signature BLUE_HOOP_SIG = vex::vision::signature(5, 0, 0, 0, 0, 0, 0, 3, 0); // blue hoops get detected as blue balls
vex::vision::signature GREEN_INDICATOR_SIG = vex::vision::signature(6, -4647, -4369, -4508, -3549, -3157, -3353, 2.4, 0);
vex::vision::signature YELLOW_INDICATOR_SIG = vex::vision::signature(7, -1699, 101, -799, -4119, -3775, -3947, 3, 0);
vision camera = vision(PORT15, 50, RED_BALL_SIG, BLUE_BALL_SIG, YELLOW_BALL_SIG, RED_HOOP_SIG, BLUE_HOOP_SIG, GREEN_INDICATOR_SIG, YELLOW_INDICATOR_SIG);
const int CAMERA_PIXEL_WIDTH = 316;
const int CAMERA_PIXEL_HEIGHT = 212;
const int CAMERA_HORIZONTAL_FOV = 61;
const int CAMERA_VERTICAL_FOV = CAMERA_HORIZONTAL_FOV * (CAMERA_PIXEL_HEIGHT / CAMERA_PIXEL_WIDTH);
const double RADIANS_TO_DEGREES = 57.2957795131;
const double CAMERA_DEGREES_PER_PIXEL = 0.193037974684;
const double CAMERA_RADIANS_PER_PIXEL = 0.00336914823961;
const double WIDTH_BALL = 2.1;
const double WIDTH_HOOP = 0;
const double WIDTH_INDICATOR = 0;

// array for storage of currently held balls
std::vector<int> ballsHeld;

// array for keeping track of the ball types of detected balls when they get combined into a multi-scan list
std::vector<int> BALL_TYPES;

// boolean that can override the ball-search function in case time is low and it is a better idea to shoot existing low amounts of balls than to look for more balls
bool timeLimited = false;

// long for keeping track of the previous time position was calculated (isn't implemented yet, idk how time works with c++)
//std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();
//auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);
double previousTime;

// calculated position coordinates
vector3 position = vector3(0,0,0);
double heading = 0;
double armAngle = 0;

// image to try and display on the screen for funzies
std::string image = "30279c3328a12c2ba02d2ba42c2ba62e2aa62b2aac252baa282cab2c29af2b2aac292baa2e2baa282bae2929ae292aab2d29aa282baa2c27ad2b29ac2b27aa2f26a52b26a72927a93225a42927a42c24a02a249f2c249f2d239f2e229e2d239c2e23953021962e1f912c20922a1f932d208b301f8c2e1e8b311f892b1e882e1e842c1d822c1e822b1b812d1b812b1b80281c7829197c2a1a7e2c1a772f19772b19752c18742818732a1973291b7026196f29196e27186e2b186e32176e2c186a2418662d166427166027145c3627a43229aa352aa9322bab322bae322daf2a2db02e2bb42a2db22f2cb42d2cb0302cb42e2bb32f2eb23129ae2e2ab12a2cad3029af322ab13329b12d28ac2b28ab3327ab3227ad3125ab2d25a72b25a43023a73124a23124a32e26a03326a02f20992f1f9a3021992f209431209a321f942e1f912e1f8d301e8b2c1d8d301e8b2a208a2f1c87321d862e1d7f2c1d81311a7f2d1a80301a80351b7e2f197b31187b2f19762e19782d18792a19762c19733019742e18722d18703217702c186e2e176a2f16692d15682d1667302daa332bad312ab12d2cb0312cb1302caf302cb42b2cb32d2ab4322bb3302cb12d2bb4342ab3272db2322ab4322ab33229b33129b22f28ae3227b0312aab3426af3227af3227ad2a27ad2f25ad2e26a92d25a63225a73124a63224a230259f2f229f34229d3321a0351f9b321f983021942f1f91301f91311e91311f8d2e1f8a301e8b2d1f8c321e892d1d842f1d852a1e833119822f1b7f2e1b802c1a802a1a7e2c187d30197b2f19782d17782718752c19732e18722f187233177230176a2d18672817692e176b2f1665392bae2c2db22f2cb52d2cb62e2db52d2cb62d2db62c2db62d2db72c2eb42e37b22e2cb52b2cb22e2ab52b2bb42d29b22f2bb22b2ab3302ab43328b22c2aaf2d29b13427b13427b12f28ab2e26ac3125ab3124a83324a62f23a72925a23023a13223a02f239e31219c31219c301f9b2e1f96311f9b2d2092311f902e1f902d1f8f2f1e8d301d8b2f1e8a2f1d862f1c852d1a872a1c832b1b812b1b832a1b802b1a7f2d187a251a772b1a772b19772e1b782a1a782d18742c18723019732f17723117702d196c31166b2c176a352bb2332db52f2db8352eb7302cb92e2eb42b2eb9302cb7302bb82f2cb72d2db52d2cb7292db7302bb72e2ab62b2bb3302bb62d2cb42b2ab22f29b8332ab43028b22d29b33029b22e26ae2d27ad3325ac3324ab3024a73324a82e24a63023a72f23a12d21a42f20a033209c2f2096321f9c3021972f2395341f962f208f2e1d90331f8c2f1f8f2e1d8b311f892d1e882d1e862f1b88331a832d1c80331f80331b822f1a802e1b7c2f1a772c1976281b773219793119743218763217732f18742c18722b186e2c176b2f176c342eb8322db82f2cb92e2db82d2eb82d2dbb2d2eb82f2dba2e2cbb282cba2d2cb6312fba282db82e2bb42d2bba2b2bb6302ab92c2bb72f2cb83429b72e2bb4322ab83327b63229b22d29b12d26af2f27ae3025ae2f25a82c25a62e25a83323a73024a42c24a12f229f3221a22d219e31209e32209a2f1f962b1f952d1f952b1f902f1e8f301f8f301d8a2d1f8a2b20852f1d872e1d892e1c832e1b842a1b812f1b81311a83331a7f2f197b2a1a7c33187f301a783017762e18752d1873271a722e19713317732f17702d186e3b2db9312fba2f2fb9292ebc312cbc2d2ebd2b30bd2f2dba2b2dbb2e2ebb322bb92e2cbb332bbb2a2bba2f2bbb2c2abb2b2cba302bb7312ab92d2ab9312cb82d2ab62b2ab82c29b5312ab33427b13326b02e27ae2f26ad2e25aa2f24aa3224a73322a73121a63123a42e229f30239d30209d311e9b3220992c20992b20952e1f9231208e2b1e8f2e1e8f2d1f8e2f1d8f311e8a2f1c8c2d1d8a2c1c832d1d852d1d7f2a1d82301a81311a7b2e19802f187a311b7a2f19772f17772e18732f18732b17742b19702c177131176d392fbd352dbd342ebc302ebc2a2ebd302eba2830bd2e2fc02b31bc2c2bbf2e2dbe2e2dbc2a2cbc2c2dbc312cbc312cba312abc2d2cba272cbe2e2ab7312bba2b29b92e2ab72e29b52e28b42d27b02e28b22d27af2b26ae2f25ae3123ab2d24a93624a63024a63123a33223a42f229f2f219f2d1f9d30219a31209b321e992f1f99321f952e2090332195321e8e331d882d1d8e2d1e8b311e872b1e852e1c87321a842d1a832e19802c1a812e1b7e30187d2f1a7b2c187a2c187a2c1876341a752f17743218712f17712b186b362fbc322fbf302cc02a2ebf2f2fbd312fbe302cc02b2ebe2e2dbf302dbe2f2ebe2e2dbb2f2cbe302cbc2e2dbb292dbc282dbd292dbc2e2bbc322bbc2f2cb92e2ab9282aba3129b92d28b62a2ab52f27b13027b22b25b03326af3226ad3224a93123aa2f23a93323a83523a330249f2d22a03220a131219d31209f312098301f97302094321f96321f932a1e92301e8c2e1e8b2b1f8c2d1d89301c852e1d87311c862b1a822a1c842c1b80321a80341a7a30197b2e1a7c3018782f167a2e1c7c3218763018742919732d17713930c0332fbf322fc02e31be2f2ebe2e2fc02d2ec22a2fc02d2ebf2c2ebf2b2fc0292ec02c2dbe2b2fbd302ebf272cc0292dbe2e2bbd2c2bbb2a2dbc2d2bba2f29bc2b2bb7302bb82f29b72b29b32e27b13227b12c27b23127b13226b12f25ad2f23aa3224a83524a73024a33221a531239f31219e2f21a0341f9c2c209731209a2f1f962e20952f1f95331d94291f8f2e1e8e301e8b2b1e8a2e1e882e1c862f1c852d1a873219882b1a82301981321a7d301a7d311a7f2f187c30197a3019752e19742c18753118722817723632c8312fc52a32c22830c32c30c12f2fbe2b30c1292fc12b2fc52d2cc42b2ebf2b2ebd2c2fbf2a2dc32a2dbe342dc12a2dc02e2dbe292cbe2a2cbd2d2cba2a2dba2a2bbb2b2bba2b2ab92d29b93227b62b29b73128b53027b23026ae2f25ac2f24ac3124a93025a73324a73023a430249f3421a23021a132219f33219e30209a2f20962f1f993020952a1f93301e962d1f8f2f1e8d321d90311d892f1d892d1a872e1d862e1d82311b852b1b82311982311a8230197e2e197c3019792e18772e18792e17763018742d1771372ec43232c23031c23231c12f2fc6302ec12c2fc2302fc52e31c52f2ec52c30c1262fc22a2fc12e2dc02e2dc02f2dbf2e35be2e2bc1282dc02a2cc02c2cbf2b2cbc2c2cbf2a2bba292cb82b2ab62d29b53429b33227b53429b13525af3226ae2a24ac3122a93125ac3526a93622a63323a43421a62c22a031219e2f229c32209a2f2096321f98301e94331e94311e912f1e93311d8f2e1d8c311d8e291c8a321b89301d85301c852c1b84321b812f1a842c1a832d1a7d2f1a7b2e197d2f187b2d18772d1778291873351a783331ca3130c63130c52831c33131c52d32c32e2fc72c30c52b2fc62c2fc72d30c32e2ec42930c12b2fc52c2ec32d2ebf2d2ebf292dc22c2dbf2c2dc02b2dc02e2abd2d2bbc2f2cbb2b2aba2e28ba2d2bb92d28b62d29b42f28b12a27b22a26ac3024b03124ab3026a83323a82f24a52d22a93020a73321a43320a031229f31209e36219e301f99311f97321f972f1f97321e922e1f90312090301d8b351c8e331c8b2b1e892d1a862d1d842d1a852e1c822d1b822c1a812f1a7c2e1b7f2f197a2e19792f18782d18763119723133c93b30c92731c52c31c82c33c72831c42831c62e31c72a33c72a30c72b30c72730c52b2fc52b2fc12a30c5282ec6292ec42c2dc32a2ec12e2dc32b2bbe2f2bbe272cbb2d2bbd2f2bbb3327bb2e2ab93127b73430b82f29b42e27b32d26b23024af2b24ae2f25ac3125ac3024a83023a92e23a62f229f2c23a132239d2f229e321f9d2e209c312199332096311e95312092321f922f1e912f1f8d321f8c362093311d8c2e1d88321c892d1a88301b84301b83311a832f198031197d301a7e2d197a3118752f18762f17743530cb3331cb2b32c82832c72c32c62e31c82931c82234c82e31c82732c42b2fc62a31c42c30c32a2fc4292fc42730c32d2fc62a30c3242fc1282fc3292cc0292ec12a2bc02c2cba2c2bbc2a2bbb2e2ab92c29b82b29b73028b63126b33126b12e25af3125ae3124ad2b24ac3023aa2c25a73022a82e21a83323a33022a53520a12b209d31229f32209a2c20982e1f992a1f92301d912d1f90301e8e2f1e8c2f1c8e341d8c291e8b2c1e89311d86311a832a1c80301a832b19802a197c30197c2e1a7d2d1a762c18772b19763231cb3032cb2f32ca2534c72934c82b33c92533ca2832c92b31c92b33c82a32c82c31c92c2fc82b2fc62c2ec7292ec72d2dc5292dc62e2dc32c2dc7312dc32d2ebe2c2bc22f2ebc2f2abe2f2bbb322ab92c2ab93427b72c29b53126b62d27b32b25af2d26ac2c25ac3124ab2c24a72a24a93224a73122a83123a53522a630229f34209f2e229a2d229e31209b2c20972f1f932e1f932d1f90331f8e2d1d90301e8d311e8c2d1d8b2f1c8a2d1d87341d872b1a80261a823119802b1982291b7e281a7e2f197d2d19782b18743532cd2d34cb2a32c92a36cb2f35cb2c34cc2b31cc2d34c92832ca2931ca2731c92932c92931c42932c9292fc92930c62e2dc72b2fc62a2fc52d2ec32e2dc22b2cc32a2dc12c2cbe2c2fc92e2bbc302aba2d29ba2b29b9322cb92e28b53126b22e26b12f28b02e26ad2e24ac3024ad2f26a82d23a73224a53123a23021a42c23a03320a031219d34219c311f9a2e1f972f20962f1f94311f92301e91311e8f2f1d8d2b1e8e321d8d2f1c8c331c8c301b892d1c87311c852f1a82301980301a802c1a7f2d197c3118772d19772e36cc2e38cd2634cd2e33ce2835cb2735cb2c35cc2b32ca2735cb2833cb2b31c92a33ca2b32c92c30c82d2fc82a30c82530c72b2fc72c30c62c2dc52e2dc42e2dc12c2dc12c2cc22f36c12e2bbb2a2cba2d29ba312eb92d2ab92c29b83028b42f26b33027b03026ae2f25af3425aa3324ab2c24aa2f24a82d23a62c24a43322a23421a13021a02d229e2d1f9e30209a321f98301f962f1f932b1e972c1f8f2f1e90311f8f36238e2d1e8a2d1d892c1e86331b872f1b842f1c872d1b81311a7f2e197f3319792f1a763218763136d02e33d03134d02e35d32b35cd2f34cd2335cd2735cb2635ca2a35ca2433c82b32ca2d34cb2833ca2730c82b30c92933c62a30c72b2ec62a2dc52a2ec62e2dc32b2dc5272ec22d2bbf292cbd2b2abe2c29ba292ab93027b72d27b63126b12e26b12c26b23124b13325ad2f25ad2e25ac2c25a72b25a62f24a72e22a53622a631229f3322a130209d3320a02f209b3120962d1f93301f972b1f932f1f94301f8f301b8f321d8e301d8c301c8a2e1d892d1c892e1e842e1b832c197f2e1a82331a7f2f197a35187b2c18753135d13235d12b34ce2a34d02436cf2b38ce2435cc2c33cd2735cd2833cc2b32cb2233ca2533ce2732ca2334c82731ca2630c62531c72e31c82c2dc52b2fc5292ec32b2dc82a2cc12a2ebe2e2cbd292abd2c2bbb2d29ba2a2bb7312ab93028b63325b33025b12c28b02f27ad2c25ac2d25aa3023aa3325a93224a63122a62f23a43021a32c20a03221a0301f9c2e209e311f993021982f1f963120932d1e93302191311c90301d8d321d8c2f1c8a2c1c8b301b882f1c85341d85331a832c1b7f2f1b7e2a1c7927187a2f1a7a2f36d43133d22c35d02736d22634cf2f36d02634d22a35ce2a33cd2636cf2434cf2434cc2a31ce2a31cc2731ca2731cb2e2ecc2930c42a2fc9272ec9312ec92a2dc62e2cc6282ec0292dc13129c12c2cbe3329bb2a29b92d2ab82a28b72d28b42f27b12b25b52d24b03324b32a25ad2d25ac3323ab3223a92c24a73222a53122a23222a53123a03320a232219d31219e311f9c32209b30209a301f93331e972b1f922e1e93311e912f1e8b2a208c2d1d8a321c8a311d87321c872d1a852e1b7f3419842e197d2f197a2e18782e37d22b36d32f35d22736d22937d22836d42636d02a34d12934d12837d02334cb2834cd2a33ce2334ca2c32cc2730cd2632ca2830c82b2ec92430cc2c2fc5332dc52d2dc42e2ec22c2dc12d2dbe292bc0302abd2a2abb2c2ab93028b83027b52c29b12e27b23027af3126b02e25ae3224ae2b25ab3025a83223a93323a63621a63121a62e22a23121a334249e31219b32219d2f20962b2096321f952b1f932d20932c1f8e2e1e902e1d8e331c8d2d1e86301c8b2d1d86301b86341984361d812f197f2d197e311a7d2d187c3137d32c37d32637d12737d12837d32639d12139d12536cf2338d1363dd22636cd2833cf2735cf2734d22536cc2a31cb2930ca2930cd2b31c52831c9252fca2d2ec72b2fc6292dc42e2cc12a2cbe2e2bbd282cbb2f29bc2a2bbb2d28b9372db73127b53125b42c25b32f26ad2e26ae2f24af2d25ad3124aa2f31bd3324a62f22a53321a73022a03221a32d22a02d229c2e209b331e972d21962f1f972d1f972d1f91321e91301c912c1e8f2f1e8e2f1d8b2e1e892f1c882f1a86301b83301a843318812d197f2f197b2e197c363ad43138d52d37d32a36d12738d22537d42637d32638d22735d32338cf2d37d02336d12632d32831ce2e31ce2633cc2333ca2932cc2333c92d30cb2a2ec92c2fc6292ec52b2cc5292ec3292dbd2d2bbe292cbb2b2bbb272ab92c29b92f29b42b29b52f28b42d28b33028b12b26ae2e24ae2c25af2c24ac2d27aa3024a43123a62c239f3122a22f22a431249c2e219d2f219c2e1f9a3120972d1f98302097332096321e912f1e8f2a1e8f301b902f1c8d2d1e8b2f1c852e1d85361b84311984291b7f31197c321a7f2d197b313bd53037d52938d42139d42539d32738d42438d32638d32539d02638d12b36d42337d02533d12536ce2734cf2233cd2434cc2432cb2432c92f2ecc2332c7272fc62830c72730c42630c22a2dbf2b2cc0292cbe292bbc2d2bbb2c2aba2e29ba2d29b62f27b52c26b33025b33126af2f27b12f2bb33228b02b26a83123a92d24a42f24a22f21a32824a331239e32219e2f1f9f3220992c209b311f96332094301f962a1f972d20902f1e922c1e8e2d1e8b321e8c2e1c852e1c842e1d842e1b843219822e1a812d197c2d197e323dd32739d62937d42839d62539d4213ad21f3ad42339d02837d32238d22138d12037d02336d22136d02434cf2635ce2434cc2433c92932c92932cc2631cd292fc8282fc7292ec22f2cc42d2cc12b2cc0252dbc282ebb2b2cb92e2abb2b29b72c2ab82c29b62d29b12f27b22f25b12c27b02a28ac3325a82c27ab3024a92e24a62b25a43421a42d23a03322a131219e2e209b31219c311f9c33209d2e1f963422a02f20962f1e93301e902e1e8b2b1d8c2e1d8b2f1a892e1a8a321c872f1a86331b842e1a7f2a1980311a7f2f39d62f3ad82a39d6283bd4203ad42639d52a37d42637d72836d42436d32737d42d38d12834d62335d02534d12736ce2235cd2334ce2537cc2435c82a30c82a30c72b2fc82630c42a2ec12c2dc0312cc12a2bbd2b2cbd2b2cbd2f29bc3029ba2c2ab72b28b92d2bb12e29b42b26b02f27ae3026ad2e25ad3027ac3225a83223a63025a32e23a32f24a03022a02a219c2f209f30209d30209d2f2097311f96311f932d1f952e1e91301d8f341f8e2e1e8b2f1e8a331e892f1b862d1b86331a83321a812a1a7d2e1a81291a7c303bd7253bd5253bd5263ad5253ad62b3ad6233bd42339d62937d72337d42739d32237d32437d42435d22436d02335d12235cf2534cd2632cb2832ca2731c82631c92131c72531c32c2fc32d2ebe282dbf2d2cc13131c12e2cba2b2bba282cb82d2ab82b29b63428b42b29b22c27b63028ac2d26ae2b25ab2925a93325a33023a93024a32c23a22c23a32d22a13122a23320a030209c2e1f9b2f1e9c301f962f1f95342095321f912f2094291e8f2f1f8b311c8c2e1d8a311c8a351c83311d85301a83311a80311a802b1a7a323bd8323bd6273bd3203bd42239d6233cd62339d62338d52339d42638d5203ad32437d52435d42836d12037d12935d22635d02632cd2431ce2931c82c30cb2832c82730c9292fc62b2ec2282fc3282ebd2a2dbd2c2cbe2b2cbc2b2cb92f2bb92d2bb92b32bc3947e13939d8a1a3f42a54a5282baf3129b32f25ab3024a72e25a72e23a82f23a33322a43622a42c229c311f9d2e209e3322993020992f1f9835229f2e1f912f1f912b1f90301f8f311f8a2c1e8a311f892f1d862f1d8a321d85301a82311c802c1a792e1b7d2e3cd62b3dd5263ad72739d8293cd6233bd6273ad5213ad52239d52838d32238d62338d52536d52735d52535d42334d22337d02435cb2733cd2b33cb2033c82930ca2831c82731c6292fc6252fc32d2dc1262dc02d2dbd2a2bbb2a2cbb282bbc2d2cbf7586ea828add6b7bb9818fc7627abc2c47b33559cb2b28a72f25a92e24a92c24a83021a43323a02f23a02e229f2c239c2b219c2d209b311f9c30209a2d1f963020933220912a1e902b1e8f321d8d301c8d2c1d8c2d1c86321e862b1c862f1d812c1a842f19822c19812a3dda2e3bd62c3ad8223cd7233ad8263ad92739d7253bd72139d42938d72238d5253ad52438d42238d42737d22637d22436d22533cf2434cb2334c92335c72a30cc2430cb2730c8292dc6282fc62a2fbf2c2cbf302cbe2b2dbc252dbb2a2cc37179b98285c08a93d14d6ca5536ca6989acb8695e4345bb52d2d893025aa2e25a73123a62e23a22d23a13022a22e249c2b229d32219b2d229c30209a2c1f992d1f942b1f932c1f922d1f8d2b1f912f1d8c301f8c2f1e8c2f1d872e1c87331b882a1c872d1c822a1d82321a7d2f3dd92b3cd8223cd9223bd8223cda203cd8203bd61f3ad5233bd5243bd9223ad4253ad22239d22436d62438d22138cf2935d42434d22534d02334c92631cc2432c92432c8272ec6292dc72b2ec42c2fc2262dc22c2dc12f2cbb292fbead9bad8288d03c428a4a609438415c9a9dee4a4052a38a7f677bec2448a25d77da404ee92c27a62e24a23023a32d23a12a23a2273a9e33229c31229b2f1f9e2f21992f1f982f20912b1e902e1f8f2a1f8d2b1e8e311e8d311d8c2e1e8c2c1c87291c832e1c832b1b842c1a822c1b813e3ddb283bdd213cd9293bda233cd8203cd7223bd7223bd7213ad6233ad41f39d52d46d82337d52538d42837d42238d32337d12735cf2236cf2933cb2433ca2731cd2631c82831c82a2fc5282dc6272fc22b2cc22a2ebf2a2dbd3e3cde98829d937799816576352c3c6268929398d08a92c43a408c5e7bc020498f4566c65977d32c46b02a2a963023a02d23a42e2a9e32229f2d229f3222992e219b32209b321f9a321d8f2f1e90302092341e92321f8f2d1f8e301d8f291d8c301b892d1c852d1b842b1c81311a812e1e802e3ed8333cdc2c3fd8243eda273dda233bd82939db273ada243ad9213ad6263ad52438d82438d42438d22138d32437d22435d42536ce2835cf2533cb2a31d02433cd2b31ca2432c82531c52c2fc02e2cc22c2ebf2d2dbe2c2ebccab5c181605ea2726dbbaad3504370918aca5e658a8070988687c833476c2b3a628692cc4566a64367c628327e2c288b2645b62f23a030229e30209c301f9d31219d3220992f2193301f97301f912d1e8f2f1f8f331f8f2d1d8b2d1f892f1c8a2d1c8a2d1c872d1c883119852d19822e1b7e333edb2b3ddc263cda263dda213dd9203cd9253cda223cd9243ad8253ad7253ad5203ad52239d42637d52738d22137d12336d22734d32338d12535ce2a33cd2734ca2c31c92532c62830c72b2fc62631c22e2dc02a2ec02a2fbd9c7271bca4a7946e8a8c6a6f8a74bb9c8eab384d6f7468767f83b52c253d2a23397f71764d483e9fa8f52c54b3273f9927338c3121a12e229c30229b2f219e2e2297312099301f98331f952e2195321f95301e9131208e2f1e8f2d1f8b301e89321d8b2f1c872b1d83301a83291c7f2c1a7f333ede2b3fdb2a3ddc263edb243bdd1f3cd8253ad81e3bdd243ad6223bd61e3bd71c3bd32039d71e3ad41d39d32438d12338cf2336cf2735cf2634ce2433cd2436c92633c92b30c82a2fc72730c42830c22c2ec1292fbe2a33c087698888604da5919fa690a28b749c584a4637405a9d8ead5f5a792d31503023414652426167bcc2bbde6575ca2844a02a37982e229e2f239f2b229c33219e31219932219d31209a2949ba2e20932e20942f1f922c1f8e301e8d321c8e321e8b321d862f1c892f1c85301c88271c83311a82363fdb323fdb283bde2f3ddc263ed9223ed9213cd9213cd92842d9253ad61f39d9223cd52238d51e3bd41f39d12636d32436d12537d12238cc2835ce2735ca2732c82234c72831c92931c72231c22b2ec42d2ec1292ec03549c9ad98a0776173725f66785e6ea0a0ce37231f393d62b5b1e37b7da330375b2d315b4d594ea7aaf3949eeea8adf22b5b96253f7d2a328b2d239b31229f2f229a2e229d2b21982445a62e2296312098331e932f1e902a1e8e301f8e2f1e8c291e8c301d862e1c8a2c1c872f1b852c1b82301a83303fdc2f40dd2640db2641db223cde283bd9243dda243dd92440da243bdc1d3dd72540d32a3ad41f3ad51f38d31c3ad01e39d22835cf2138cd2634ce2632cd2435cc2932c92531ca2531c72532c42831c52531be2533c07069a368504b966f638966708f6e8c624736321f21353d59baaacc8285ac3c56932c3b7659543fb8b7e9a0a6ea9695b14965a72c4fa5293a91252b7b2a2d7c252c8231229b2047a72c21972d20982e2198331f95311e922d1f902b1f8d33238f2d1e8d2c1d8c2f1c8b361c872f1c82301983301b823841dc3040de2a3ddc243edd233edc243cdb273dd82a3ddb1f3eda273dd91f3cd6253ad7203ad32339d32339d4223ad12139d12139d02437cd2534cb2735c92333ca2533c72931c62a32c72b30c12832bf2931c174696885604c7654477a5c5c583c34aca8e93e23212a181b382a35b290a5988eb26979b42e32583c271fb9b7f27d8ab74a517c8f9de23961a32a3c6a2a2e73292c67272d6829307e2b2e8c26349025318e2f20962c1f952f1f902e1e92331f8c2e1e8e301e8a331d8d301f892f1d8a2f1b83301c852e1a84313fdd2d40dd2240dd283fe01d3ddc293ddc2640da1e3eda213fd9213dda203bd7223bd7233bd3223ad3223ad12738d42138d02537cf2136ce2436cc2931cd2234c92433c82434c82832c42831c22533bf5c60868c6b5c7c74aebfbafc6c4d3dafa8e18171762c191823141b372223af8da1ada3cd858dd42e2c49372321afb3f0506a98486fab99a4df2b59882342842049982b2b6a2c2c6f27306f26357324398328337e2b2d852e22932e1f952f1f922a1e912f1e90291f8c2e1d8d341d8b301b8a2c1d86291a852c1d803542df2b41dd233fdf2a3ede2a40de203fd9273eda1d3fdc223fd8213cda1e3bd9213cd61a3dd51e3bd31f39d32339d2203ace2538d02535cf2535cd2735cb2534c92537c62932c72332c22433c13e4f8174595384583c6e6279a98d9c6c4e489675963d262234201f1e10143c2120b19db9b1a8d39e98d1322e432c1e1e9179657581c25c74b66072654d70b32b56a12652832c2661272b5f242f6626346b25397b26377f272c752d20912b1f972d1f92291f90341e8c2c1c8d2f1d8d2b1d8a2c1d892e1c86341c862e1c823642df3241dd2b41de2741e02140dd293edd253edc273bdb213dda1f3bd9203cd8243cd8273ad51f3ad4223ad0213ad0213ad02437d32038cd2434ca2434c92334c82433c82634c52735c57078c2624c408861538d7584a481846b4746a98283a89ed6433432493837221217432923b0a0d6bcb1e29088b4382e3e301f1e785f57737cb8496aa8403330657cc8496bac2d3e5b2e34812b27522c2a58273165263b7a2838772b327b2928822d2195331d902e1e932f1f902f1e8e2f1e8f2d1c8c2c1c882e1c882d1e842c1d833043e12d43e12a41df2243dd283fdd213fdc273fdb243ed9293cdc203cd9223dd8263dd4203bd61e3bd42239d22237d12439d02237cf2636cf2737c92635cc2533c92733c72333c62837c772565a795852785e77835c547c4f42cab6d59d7590b398af565a60473d412313154c2e26cfbef7ab98be9e98cb342531352926a88272626da832537b4440347784d1547abe29355223479d2e295c2829562731662e397625397222387d2525702e1f93301e91321e912e1e90301e8c2b1e8d301d8b2c1b8b2f1d852e1d862f1d823b45e13545de2b40e02841dd253fdf2842dd253fdb223fdb263fd9213dda1f3bd7203cd6203bd62539d41f39d3243ad12436d02635d02336cd2636cc2633cb2634ca2b35c52932c87d6a79674c3e75596e977da8744d3da26e5b89533ec4aac1a5858b4942374b3a3c2d22257b4f33c7b8edcabffc68719c3024304230268b65496976b24160a34441368d97e0657fc5282e4e3259a22f2f652726542d2d6026366b283c7c273a812a2b74311f902f1f932d1f912c1f8f301d90311d8c291e8d311c8a2d1d872d1d862e1c813843e23841de2943e02342dd2940dd2240de243fdd1f40d9243ddc263dda223bd82639d7243dd4223bcf2438d4243bce2638cd2536cc2136cb2438c92535ca2934c82736c4293ebb865e4e7f5b6d75668d995f459d6951835b496f4633ab92be91706e4a3b404837383c2a25a16a42c2b7eac9c0fc9786ac33324a402c2489634b737cbd3e69a83e3f49929be35979b9292f513d60aa273369282559282f6328356b243f7a2a3b832733752e2280302093301e902d1e912d1e8f2b1f8d2d1f8d2e1e88311d88291e832a1d834045e23341e22a42e22643e22643db2541dc273ddd223dde213edb233ed9263dd7223cd61f3bd4233ad3223ad21f39d12338ce2536cf2238cc2436ca2537c82437c12038c4786486836389755f6d8e665986523a7e5440895e418f6359af9ccf8b7b985754594432364d392e9b6042b6abdac3bdf69a8ba6373a58482d299474655e77b93b5fa03241679495d94c72b52b3364375c922a38812726552a2d602c3a74273d81243e892934852622653120942f1f902e1d8f331f8f2e1e8d2f1e8c2f1f8d2e1c892e1c862c1c873545e23444df2a43e02e47de2240e02640df2440e02a40da213fd8233ed71d3ed6263ad9213bd5213bd1203ccf233bce2937cf2339cb2636cc2a38ca2735c92436c7afaeea7860717774bbb07b6fa37f9193615a8b52368b56388c655eccc3f7917f885457613c343a625451c9b0c6ada0cbaba4d17460745159833c2b284f3d305972aa2b436d3755898996d2385e923042882b517f3052af2a296126315d253e80223c812a3d88283583282462312192312091322393321e912b1e8d2e1f8c2f1d8b301c88301e892e1c823c44e23544e12945e02440e12842dd2642db2340dc2a40dd273ddb203eda203dd91e3bd6213ad41f3bd0203ad12039cf2738cd2536cd2637ca2437ca2637c52e3dd47b5d678280c0c3b0d49e6c6cb18e97dfcdfda76b4f8c6348bf949bc1b3e0827b95595f6a3f3643825637c79798a397c1a5a0d8ac7c797e708c302b3c3d3133486172456fbb254b7b8b98d0405d92395db2274d7d406ec72a41862b3369224283223f8f303fa0464bbb322e8d3a59cd6c7be45c75e36677e67282ec4f4de1301c8e2f1e882d1c862a1e863945e13444e22644e02f47df2343e22842de253fe1223edd213eda2040d8223bd71f3cd41f3cd41d3bd3233ad02338ce2039cd2737cb2238c82039c7213ac75a68b8694e50a095e4755049794b41874f31bd7a5fb16e509f6357a77268c4b5d878798c5c5f7b3a45598a613dbd94a49890c1b0b0efad7961827a93342e493e313359636f7c8cd5274f845f72894764a24169ae2a4a765574be2b44772b30673b68c28494eaaeadf295a2ec7486de374cc92f21952d20942e1e912d1e902a1f8e2c1e8a2f1e8c301d86281e834348df3043e32a41e13346df2842df2844dc2343de223fd92140d71e3ed81e3cd6223dd52239d2213ad3223ad12837ce2438ce2138ca2637cb2539c84448e26450618376b4b5846b8e5e46cfc3fc7946299a5934d9bce1a26548a785acc6b9dfa29bd15a5f713d5779a16c49ba9fc19390c6bfb6f6a36d479b83a32629443530364e4d418f99c73a569035507d6c84cc3e609a2b43734c6ead2b3c6f2d4790a4a8fba0a8ea918cb17679b23630773622894d4297566dd9341d8e2b1f8d2e1d8c2f1d8a2c1e8a301e872c1c843945e13348e02e44e22f45e03142de263fe02242dd2940dd273fd8233fd8223bda1f3dd4203bd2213ccf263acf2838cf2538cc2639cb1f3bc9243dc475566762444ad5cffd8a56429c7071c69081965c36ab684ab770518d5b3b926255cbbae28b85a75d5f745b6997b5754cd0c2fb7a7fadb4abeda2694c9683a62c2b4d30578c73799fa29fcd6771c43658897986cf4866a22a3d6d365f9b9f9feedbd2fec3bffe7781c55371ae345ea528204c3021802e209430208f2e1e8f2d1e8f291d8b2e1d89311f872e1f87281e883646e03144de2c46e03044df2644dd2940dd1f42dc2d41db1f41d7263ddb1f3ed7223ad5243bd4233ad32339d02638cc233aca233acb1f3cc7a79ab5624c509580d0bd8d968e606ac4afef9e6553aa6e58a56440ab68458e5c4ac2b6f1d1bee18485aa636480616276bb7a57c1b5df7a7fb48e8dc3b98c7f9c8aae3b3f654465a88e88a39e8ead9296d73a5f9c717fc44a5a8d2d3463929adbded3fbdabbc8c2bcf85973cb2e5b99282453251c4129217a3120952e1f912f1f90312193301f8d2b1e8c2d1e862d1d852f1d863245e23046e12a45e12b44e02542df2843de1e44de2740db1e3eda233dd8213ed5213bd61e3bd2223ace2538d1253acc243acb253dc93648de866f85937acfd8bbc1a475727d4c378d5a4491583c995838ac6949a05e36a47c97a37f8cd9cbf98684ac636f8d7173a0c4a1b4cec3fc7b83c1706584ccaab59188b14a5f954067b39593bb9f94ada2abed385689617ec1465c912d4d7bbeb7f0e0c2d0cfc7fd8a91dc295794313c692b285d241d45291e633522972e1f932d208f2c208f2d1d8e2f1f8b2e1f8a2d1d842d1c893045e12f46e13043e12b45e02b42dd2c42dd2042dc233edb223ddb253dd71f3dd81e3cd5243bd3253ad2243ace263ace263acc2740cfc5b8cb836177cfb3bbad7b7a97634bac6f57ad7a6d9a5e3ecea1a29e5e3aac7160a66a4da97b96d6c6f19593c26f709d8889c4c0876ec0b7f08f8fd14f4d61c4b2c98183af898ed133568e8b88ada29ed9b9b7fc303e5f6982cb395c8d3e5e90c6a7b8d3cafe7983c92b4c812c3c642a477b2f3062241a41231e5a322093311f8e2c1f8f2a1f8e2f1c8e321e892a1f89331e8d2b1d883d45df3143df2842e22b44e02b44df2542e12741da2540dd2640d6203ed6213dd5223dd3253ad3203bd0203ccc1e3ccb213bcaa49fc9956f89d2bfd4905f5a9e6b56a76b53bb90b6ab745dc48f86ac684192552c9d6244945e3eab99c5cfc7f18d88af5d71a69193d0cbadbabdb8ec8f95dc4f4d43c1b5da7a82b29f9cdd2f5387898dcaa09de0b9b5f435416f5d7dbc3757894e6a9bc7c6fd4455912b35522e304e31416d2d4e8630285b211b3f2218452c21902f20902f1f8d2a1e8f2b1e8d2d1e8f2c1e882c1f882d1d853749df3445de3046de2844df2342df2c43dc2641d8233edb273ed71e3cd71d3cd6213cd2233cd2223ad11e3ccc273acb2940cda07582c5adb8a57475cda9a7cc9c999563529f6958c08787d9c9eba16749985730aa6d5e925b40b3a0cddbcdfc7d7ca46e78a38c91d3caa0a1b9afe5828bd35c463ebeb5e58284b7a9a2e13552837f93dfa39de2a7aadf3d4b797083c2304e7a546ca1949ee82f2c4a2a233a2b325429447634559a3122572119402819471e1338301f902c1d8f2f1e903622912d1d8c2e1e86341f8c2e1e893c45e23146e12c45dc2a42de2843dc2940df2740db2141da213ed9223ed7203ed4293fd4223bd11a3dce223ace1d3ccb876b74aba5ea926454d4c9fac097d1b77e70b26e54be8372b87c75a96c4ca46548af6a46b17b76a56656bfa4d4e0d0fd8f8dc1686e979599dbcba7bcbfb3ec624c4149342cc1b4e08588b7a0a4e33655837a8bdc989ae39b99d2374d7a8996d630476f4b71ab4b63b82f27452b253c2d34592c4879294883291e4a23193f251a4b261f452a1f7f2d1e90301f8e2e1e8d311e8a2f1d89311e883822903145e03344de2b42e12d44dd2843dd2842dc283edb253eda263fd7203ed6223cd11f3cd0203bd1213dce2b3acb273ec6836ca4a1878e9a6760cc9d97b88787cb8f85c78675cfa5a2ab6950aa6b4bbe8c90b1724ea46750aa7671cbbef8ddcffd8a7e9b5f69999290cdb57f65bdb3e75d402e4f3c32c8baf3868cbd9fa0e13b59857b83d09096df8080ba374769959dde2e3b654364a02c468528243c2c284434355b293c5e2f5190231c41211a40231c47211931221d472d1f90321d8f2e1e8d331e8b301d8c2d1f8a30208b3243e12e44df2943e02641de2c41dd2440dc223fd92b3dd92642d6334bdb233cd4213dd0243bce213bcb233bc96161b8ab8a939d6b72b47f7ac6a8e1bc8c9bd29993e0ccf2b88073b16f5398655dc3a7d8ac6a4da17584b17678c7b9e7dbcbfb8d8dbe646fa97d6b75b88067baade27c75ac514134c9bef7928dbba69cd93e57746f7cc27b81c644598e4e609c6c80c47c86ca3e6ab0354189251f312a28412b2f4e3349762e2c5e221b3a271841271c471d14262315302b1e8f2c1e8e2d1f8b2d1d8c321d892e1e862d1d853744de2f44de2e42e12443dd2b43d92041d8243edb243ed71f3cd61f3fd1203dd1203cce233dca243bca3c3b79857dc28f6769b6817fd9c0dfcc9ba0d7a5aacc9385cd9382cd9c99c38c819a5c43925739a9715e8f604fa76c5bcbb6dcdbccfc8585b2737db6a492baa97958bfb8f34d3a2d544a3ec3bbf38b8cbc9e9bd3335474beaed3c1bffb50508d3044784566b132385c4674bb332966231f3529253d2c35543f589426203c24193320193b1b102826184322163c321f8d2b1f8c2f1e8d2b1d8c2f1e892e1c8b2d1c853745dc2f42de2e43dd2744dd2541dd2741dc233ed9213dd7223cd4223fd1223dcf223bcb253db5956d755e3236956975bb8377c39cc6d2a5a1d6a8a4dbacaad39fa8ce9b93c48477d8c2e0c99c9da26f5faa6b4ea4716fbd8993b797a7d6c8f98e81af898cc9a492aead8275cdc0fb553c3f4e382cc3bcf68d8fc09b9edd556379cb9982c6bce43031552e4678335191343854697bc1271c31241f302b2942344775303b65313b6e342e542421492c255329205521164128208d291f8e2f1e8f311e902e1d8a321d882c1d873242dd3045dd2742de2940db2340db1f3fd92840d8233ed7253dd3263dcf203dcd403c776e3938904f3b643032a77b76cdb1e6d9c5eed3a39ccb9487dfc5e6c38e90ce958ebb7e6ad1a7b2b37c68905c3b9e634bc39db3dbc8f86d5747bba7d48f8dbd8990ccaea4d98b705dcac4fe4a332c4a372ec0b8eb888ebd8c91ca797784d4cbfa626fa8383253334672363b623441647982c82a21333d3b613d5c8d3d578936568c2d4a7c2c40822e316d303266201f4b22183f2e1f8c2f1f8c2d1f8f2d1e8d301c8a2d1d89311c893443e02f40dd2e43dc2242db2540db2340d92542d9243ed7253dd41f3cd089759c6c3d456c38367b3d3260302fb98b8edec2d6ddbfe4d0a7b8dab8bdc2928bd19c95d5a6a0cb9693a66f5aaf735ccda7ba966347ae849fe0cffd523327c0a2c4968fc28b90ce9b97d06c5644d1c7fe502f294e342dbeb2df8485b57b79b45b6e90a7a2d94f659b6074b034344f2e2c3c516b9d6a79b66f7db66f7bba4a61895869a63f5b9531528b27478331306b2f2658291f411f14312e1e8f301f8f311f8e31208c2a1f88321f892e1c863244dc3143d92c42da2940dc2741d82a42d91e3fd8223dd92240cf434375b468508d52757f4259723a306f3535a363a3d9c0e5dec7e4d9b4c6d6aaa8cb9ea0cc9996e2c0cbcfa8bcb3795caf7465b176799e6a66b08091ddd1fc583c2a5648518d93cd878ecb777fba51423cc7c3fd5f504c452f28b79fae908cbd515f87495e7d7b84bc606c939d9fe68989c38a8dcb8189c27d82b87b80bd8985c5737dbc5872b03f5f973c5a972c47852e306e2b255a2b255623173f2d1f903021912e1f8f361f8b2c1e87271e872e1e843442dd3342db2743d82541db2443da1f3fd8203fd6223ed12942bb71403fa34f37a7738f965a876f362d743a32934936decffee2ceeed4acaee0d0fdcba097c79693ebd4fdb97d5dc28d78c08776b67458916a65c192a38f776c6058403e282ab4aeeaa5a3e3514f605f6284c3c2fd887899412a23c3b3dc8f91cd3c526b5b668aa6a9e76a6f8aa69fd79594cb9093cf8f92cc8e8fca8b89c76b80b95e74af546fa93554843252872d46832b326a2b285e2a24582718472b1f902e1e8f2f1f8c2e208b2e1f8b2c1f8b2a1e873d42df2842de2641da2d40d82940db2240d8223fd7293cd09d64a2874740944731ac737dab78ae7e3c348644498d4737a383e9ded1fed8b8c3d3b9d6cd9c95c99696d3a299cc988bbb826dbd7f66c28a728f685aa07d8f844b31442524311b1d2b1a1ca19ad33c3238433844babaf47b63704c3733ccc7fd7d7eb847596670759da09bd4b1a6d3aaa6dc999dd8a29bd79695ca7480b5575361566a9b5670ae4f6daf4261a72e51932e427c2f2c6b30255a2a204f23194d2e209031208d2c208c2c1f8e2b1f8a2e1e872c1e863a42db2e42dc2b40da2a41d92940da263ed8213dd7815253cb94ab84423fb15b3d7c3c37b690c6773a348e5479b35f406f3f3eded0fde6d4fee1d2f7d8b5cdcb9b96e0c0d7dcada7c68b7bb87f65b6755c8d6058a0727fad725c462e2721f142b1517331a1b5140394a4658412e3774656c474242c7c4fe7077aa646a7ba8a0ccbaace3b9afe4b3a9dea9a4dc9a98d464638d7a7cad8188c8767fc0707ab86771af375d952d4f912e41802f2d65292655241e48261e673120912f1f892c1f8b2f1e8b321e88301f862c1e8a3042da2841da2642d82841da223fd7253dd82340c288443dd49fa97f4339dea9ab793736b192cf814436a775adb25f3e6f3634a3606cddcdfee1d3fedfcbf1e5c3dadebaded49e8fcb9a89b5745eb27b7f915b5aac797dc59b9b39232523f124e271e7374aa8d8dca848bcab1a6e57d81b7443941beb4ef807eab5e6684b7b0e6bbb2eab6a9e2a399c2a6a0c4a9a1dc9894d48d8bca8284b8737fbe6277b8536daf3e5d9f2f528e2b41822a2d6b2c265a271e4d27207f2e1f8d2a1f8f31208e2a1f8e2e1f8d2f1d89321d8a2e42dd3440d92b40da2640d92541d6213fd57e4b637c423bce9cb77f423cdcb4d06d3633c8aded91462f9b6296caa59a703334af7358c4b5f4e3d2fee1d4fed6bad1cd9791dcb8d0c99a96cc927c8d563cb18298ab7268c3acd029161f321a189c8ca28f8fcd797fbd3e61995e73b25c6ca86d74b33c3448a19bcfc5b9edb8b3e09d98ccb5a8d7c2b2d6a6a2e0a79dd98f94d49790ce7b81bc737ebe7179bc566fb23c5f9f2e4b8c303f77302d68282254231b47341e89311f8f2b1f8f331e8c2d1f8c34238f2f1f8a2c1e883643d93442d92a41da2640d82041d82243d2904865894036b68aca7f3f39d8b5d98f4232b578acd497748c4854c8b9e2966079773831a8a4d9cec2fde4d3fedfcbead5afb4e2bccbdaaec4bc8377d3acbea6756b9d6e6fccbce326131d69351fbcb1e19e9adb8591d44a6aaa3f598c3a4d775d77bb3b3b59b2a6dfc2b8e2b9add9beacdfbcaee9b2aae6aba5e49f9fdd9298d88f91d07d85c66c80bf6d7ab95470af3d5d9a2c48872a3f752e306b282156231b442b20902d1e903220942d1e8e2d1e8d2a1e8c2e1d86321f883543dd2e42db2c42d82440d82441d43d46848b4858994d44a860af924537c5a9f4c1643f8e466cd0beef63312bb69edcc7b2dd955a5d9f8dc8beaad5d1c9feddd1fdd9bac2e0cbebe4c4e8bd846ec39ba1a76a5ba87575cdb8e62b1b248e4f2a9f7e837e8dce7e88c95970b1335b8f38476b465b934b4c6abbb2e1bfafd8d3c4fbbdb0ebc1afe9b0abeaa6a3e3999ddb9997d5898fcf8b8bca7882c3687ab9556eb1395b9a2745822f3c72312d682c1f522619432d1f8c2e1f90311f8f301e8b2e1f8a311e89301e86311e893843db2b41db263fdb2541d72a40d77b424b964a4dd77950965262d57547ab7ccade9975723431c8bcebc48560552c2ac4b1e4b6a5b86d3841aba2c89b6eb6d9cefde5d2f9d5a69dd7aba7c88a77a26c5d926558ac7670b8a8dc2e1c22c985648d756e7f86c45f7cbd5f76b83b619737485f546a9eb9afde9a7e8dd2c3f1c1b5f0b8aee5baaee9a7a5e4aaa2e0a79fdd9398d79293d2848ac97e81c26777b85b6fae2b4d7f2e3c692b2c5231264c2a1e50251847331f912d1f902e1f8d2f1f8e2d208c2e1e8c2b1d8b301d853240dc2b41da2942d82543d62841d57e4247b45a47ecbfb9904c48e7b298944768d3c3f16c302bb29ddfc3b5e168322c9272adb8a9d45d2e2caea3cda88f8ec7c1fce4d4fed9adafd5a29fd39c91955f4e9f6855976561b7a4dc361c1db16f41a29acb6578b52215254e5380304673485f903f476ac5aeccd0bfdfbfb4eebdb5ebbab0eab3a7e2aca5dfa9a2dda7a0db9a98d79d94d38387c76b7fb96379bb526faf3b57992e467a31356d272358261c44281d653421922d1f8b2c1f902e20892a1f8b2b1e8a2f1d89301c853243db2940d52642d52b41d52943cd91494ad38d79d2bced8e4a40e59061793a34d4c2f3af5c38622e30c1b4e2c4afde5f302db0a7d48b4d31a69bba9e745c967b77cecafaefd5f8dab3b5b47b5ea87162c5a6d1b089919889ba603120be8363afa7da7a87c7657baf5371ae3949666176b5baaadab0939dc8bbf2c1b4e7b8b4ebb3a6e3b7aae5b2a9e3a9a3e1a19ed5a79dd69192d1818aca7a81c36f7bb9546fb2345a9a2f45842f356c292552251b462b2188301f8f301f92311e90301f8d2e208f311e8a311d88311e842e43d93340d8273fd92a3fd8665ec1d37a58c891baa459a4e68e58e5cef9803b2fc4acefd1aba65d2e286d3442bfaad8b27b69aea5d1ac959c998db19e92a09582802a1847dab8c7e0afa6d6a8aea6706d95655690615d7a625c5f3421d4b6cea7abdd9797d28185c438507f6677b3444d67bea9b8d3c1eec9b6e2c3b4e9b4a9e0b4aee4b6aee7a7a4e1a9a2dd9f9dd9a099d69492d37f89cc7180c1687abd4f6eb33f5a9a2b45842e326b282054231a4531208e2e20912c1f8c2e1f8e31208f2b1f882d1f892d1e87281e863540dc2d40da2442d62540d1886eced2a1a6924e839a4e46eec0b1d4bdf2ca7147773641c8bdeacd947a73372976435a905747a9a0c6a79ca9866070855b419485971c111f9b91d0e6c5cfd29b949e6d678f6153ac8fb98b6c7e3a2621bf9493bdb7ea9697d46479ba6678b0535e97c1aacdc7b3c1bbb3dfcfbbeebaade9b5b0e8bab1eab0a6dab0a7e4b5a7e2989ddd9b95d48b90cf7686c7727fc06d7abb526db13255992e3d802c2c6227204d2018492c2091331e912d218b2a1f8c331f8a2e1e892e1f882b1f87311e823841d72c40d82740d7243ed48057c79f5dbf844741edab8aab687ab788dbd5c2da6e342caf93dabcb5dcc1acc1a76d67b3a2b89e92c4a49fc4a599be926c566e62621f121d332346dcb9c5d5a29ba96e689663548a615b594d455d4b32947f97a698c87b84c47a7dbc796eb0c1b1dcb79499bcb1d7cbbaeac7b7efbcaee2c5b7eeb5ade9bdaee3aca7e6a09fde9d9ad68f93d58d8fcc8287c9737ec36477ba4c65a729508e283d742e285c271c472a207b2d20902f1f902e1f8f2f1f8c2d1f8a311e892b1e88301e852d1c873142d62b40d62440d4213ed5916074894d5de07f4dc9a3fbe3c3d9833b3cd2c4f3d69a71632f2bbda8e3bcb1e1bcacdcada5ccaa9eccaf9ec5a694b2897a812c161d18d18261e34908fe8cabff6d2b4bb996a5bb9a6cfc8acc87b614bb6a3c8a188a774688b423742bfa4c5d0b6d3c4b0d8cbb8e4cbbaecc2b2e3c7b5ecb7afe7baafebafa5e3afa3dea2a2df868fd19a96d78990cf7e88cb757ec06173b74162a5234b8a2e39742e2557251a44311f92312092311f902f1e902f1e8e3820902c1e872f1f842c1f842a1f822f3ed7303dd5253fd22f3fd3ac7a7ce4986adbb7f48f453cd7c3fcdabcb88a4e7fd3c1ecc5b8de79362c8c587bb5a9d4aea2ba713b43a699bf9a90ac746f79432e2819e162a1931a7a0f1b4afef8854425e4460977faeccaecca78da0796fa177647ac2aaccb492a8c4b0d1c8b3dbc0b2dbcdb6e4c4b5e2bca7d5c0b5e7b7aae5ada7e3a6a4e0ada5e2a1a1e1a39ede9296d6888ed07c85ca6a7cc15e74b83e5fa72b48852e34712a2255241a4c30208f2e1f94301e90301f912d1f8d2b1e882c1e862e1b8b2e1e852e1d843140d62940d4253dd3243dd09257b4af77e78a4957ebcfe1833e3ad8c5fb93452d8c508fc6bbecc6b6df82422b783d50aca7d4b2a0b05a29288d8498504637321c1e1be162313269394e6aea6e08a523251362962527b746694cba4accfaab5d9b6d0bf889dcab3ddbfb1decab2d6beacd0c7afd8c39cb9c1b0e3b2a8e5afa6deb5abe3afa9e9b0a5e0a8a0de999adc9392d58e8ccc8282c46c79bb586cb43a5a9f2a437f2e3167291f4e30217d2e2190361f902e208e2b1f8c301f8a2d1e892e1f892f1e86301f842e1b842b41d62e3dd12f3ed32840d1a86871914848eeb38ca360c9e9b9a17d3a46d5bfd97b3a2f733840c0b0e1c7b4dcbc7c54bdaad4b6a5cca8939f80695b5a41302a171a2d1b221e12215c65a3aa9ad7aa9390492621a27986cc98add09eb3a96274c4848ad4b8d6ceacbfbd8b90c4a3b9c07e82c1a3c1beaddbb7a9e3afabe5bbaee4b0aae3b3a7e3a4a1e1a09cdd9e99d89691d28488cb7b80c36078bc4d68af3053912c3d7a30275a241a492d20922c1f8f2c208e2e1d8d30208a2f1f8b2f1e882f1c86271f86321b852c1d832b3dd92f3cd6223cd2283ed09476d8d5a6aaa862e0934537c29ffae0bca8975ab6d4bce9cdaba9b87751bcb1ddc5b0dfc1acd9b9a6cfa99cbd8f74724f3329361c203c22252b1e32281b37373173353051b4859bb17685ae6f6fab7478dcafbad8b9cddec8f8c4aed4a96e74332536bdaedeb795c2c0a2c5baade4b7b1eeb0a9e7b5a7e1aaa3e0b0a6e5979cda9f98d68b91ce8287c7777fbe6076b74365a92a4c8d2e3977262557241b532d218e311f91321e8c2e208c2d1f892d208a2d1d872d20862c1e852f1e83341c83313dd5323cd3293dcf2a3dd1534e9e9c56aa874642dec6ed813b3accbbf7dd9b70763e58beb2eec2b5e2baaddbb9aeddb1a7cdb4a2c7b499ad8a6c5867412f3b1f1e3f28243731522b1d303c2434c193a293677097678ccb8f95a37073c78c9cc0819fad68759e595bc799a8ad7e9ea36566ba868abaacdac1b0ecb7aceab2a7e3aaa2dcb2a3d9a2a2e1a79ddb979adb8f91d38389cd757fc05574b84260a52a4681302e6c271f4e2e208c2e208e2d1e912e1f902e208d2e1f88352094311d86321e872d1d822d1b842c1d812c3ed8333dd5273bd1243ecf3548d2d78d62e3bdc17b414ce1cbea823b36a16bd6cfbad0aa5d387d3c2d5b2b2678332a753625773524522224592e2363402f492a243c2125785e62515c8a7c5f6d8a5c64966163af7e84966266bd8085b67a76aa7b76d4adbec4a1b8bfa5cdac6b68ac6756beacd7baade8bcade6b1a9e5baa8e3aba3e0a7a1dea79fdd9d9cda9398d88d8fd37d85ca6f7dbf5f73b63a599a2d3d762f2a62241c502e209030208c2c1f90301f8f311d8d2b1f8d321f8c2c1d872d1f84321d832f1c812e1b812f3cd52d3dd1223cd3233dcf283dd2904ea6974a7ee3c0d1894462d2c3f6d8bbb96e323ac0b5edc8b7e4c8b9e5c9b8e5c0b4dfbeb2dab6a7c6b09ebb9a7c7a785a4e462e2e916271935f5d8b6174986161ad747774525f85586cc190b5d0aadfe0c5f5c5b1eaa35d728e4947c6a3b8ccadd7bdb1e2b6afe6bbace3b8abe5aaa3e1b1a3e1a89fda9a98d28e94cf9895d4888cce7481c35875b74064a7324f8f2f39722e21502e218830218e2e208d2d208b2d1f8f2d208a321f88301e882b1e892c1d862c1d832f1f812f1c812e3ed22d3dd3253dd12c3cd2263cd0d7b3bce8965eb072e7e8b18c683943b797ecd1c0e5a2553a884249c7b8ecc6b8e6c2b6e7c1b4e1c1acd6b7a1b6956f7252373c68464974504e7853609c6566a67397c37e7a805573c58884c28585c48586904c4fa95c4bd5aebac9b8e0c7b5e1c7b8ecb9b2edb18092b9aae2b0a9e4afa5dcb6a7e1ada1dea59fdb9a9bd99994d6858bca7b7dbc6674b43b5f9f264381282b64261b512e208d2d208e301e8e32208a311f8c281f8b311f8a301e89311e872f1f872d1e832f1c82301c802f3dd2293cd4213cd3263cd1203dcd755183a0527e8c4539a156d2e1c8eeb3593d813e64cbbdf3c5b8d47c352d9d5e8690547cbfabdfbaa7d1784766b19ac6b098b1885038884f419b594eb38ba9a1646cba8aafae6d6e9a5761c799bfe8c9e6dfc5e8d6c2f1cabcedc7b9eeb8b0eab7a1df9c6061bea9d7b6ace0bdace8b0a6e1b0a7e1a4a2e29a9ddd9399dc9292d18588cb757cbd576fb03555992e3b792f27602f228d31208e2c20882f208e2e1f8e2d1f8c321e892f1f8e2e1f86271e842d1e832e1d842c1c7f2f1a7e2f3dd22d3cd2243dcf263bcf263ccd3540d8ad77efe8cedb99463a8e4a98cfc0fdd4c1eb954f3d8c4157c5b6eec2a8b7ab604bc4afc888412fbf9b9e766795c5a8c39e5b4baf7676ae6a50804a4ac27b72724045dbacb3daa8acd5a1a4af6968824b5e7d444c6e36366c3838783c3e723d3bbea1b8bcaee8b9afeabbabe7b2a8e4afa5e1a6a3e3a09fdf9b9adc9291cf7f86cb6779b94c67ab2a4e8e2c346f251f612f208d2e1f8f301e8e2c208b2d21912e1f8a2f1f862e1f85301d872e1e822f1f832e1e832b1c802a1c7e323cd3283ad3283bd0213cd1243ccd273accc28d81be90f8e6cffde5c4c0823e34774052c6b1f1c39bacb96b4cc5b5e7cbb8eacab9e7c3b2e07275a0c1aacfcfafc9975741d2b4d49c6f6e985a4ed8b9c8d49a957c444ee2c2dae6cef6debbd4dec8edd2bddbd4c0e9c9bae5cbb5dac3b2dec2b2e9bfb2eab8afeab7aae7b3a7e2aca4e2aba1e1a29ede9797d8958ed07785ce7378b93f62a92b46822d255d31218d3121902c208c321f8d2f1f8a301f892d1f8a2b1f872d1f8b2e1f872c1c872c1a842d1a832e1b8028197f2f3ed5313cd2253bcd1e3cd0253cce1f3bca655891b25b498f4a4ca164b4dac6ecde9770d9916bcd9791cbb9efcebbedaf82c2b884716c3635be889fb36543d3afc2d3a9a3ceb9e8d0a4a3814b4ab17362ba90dae1bfd4c77e69a16c9ec397d5dac8eedac6f4d2c1efcbbbe3c2b4e2c3b6edc1b5efbdb1eebcade9b4a8e5aba4e3aba4e5a6a0e1a09bda9594d58689ca767dc34d68ac3153962e357b3224862d1f912d208f301f8d2e208b2f1e8d2b2089321f882f1d892f1d89301e882c1c842f1d80321b80291b7e2b1d7c343dd02f3dd2203dcf263cd0233bcd213dca223bd1a673e0eea473853d387a4045ae77deccbef6c2b3ea7e41496e302fbca2b7ac92aebd95a78d464acdc0eed7c3f4d8c4efd3a3b9d3bad8a9624edac8efdbc0c975456edac6eed9baca844649d0c3fac9a9dbab6e84ccbbed9e689bc1b5ebc2b4efbeafebb4aae4aca6e4aca5e5aea1df9f9cdd9196d78c8ed27a86cc6979bf4465ad30387226206b2d21902d1f912f1e8f2c1f8d301f8f2d20872e2089331d8c301e8a2d1e862f1e872d1f832b1d842a1c802c1c7e2d1a79313dd2243dd2293bce1f3ad02439ce233bcd2a3dcc7079c1a45db1e4ccfadccaf3dec0c0b07262cdacb9d6bcd9c8a6c18279afbd939d894238cfaec6d1c3f1cec2f3d5beeb874841d7c2efd5bede914f85d9c6f1dbc0d4773f54d6c2efcfbad8794d4fd2bce4cdbbebccbbefa25f53bdb0e2b6aee3b1a9e5b6a7deb0a6e2b2a3e2a09ede9f99d88d90d18087cd7380c85c6fb72c51912d256830208f2d208f2f208f2e208e2f208a311f8a2a1e892b1f872f1d87301c882f1e8b2b1d842e1e852d1d7f2f1f832c1d792c1a7a2d3cd52a3bd1213ccf233bcb253ad1273acc233acd1e3bcba26570884754b58bf69a89afdcbfecc07d827433397a3d34c69fb9c89980cbb2d4d8c7fad5c4f9d5c1f0cbb7e08d4742d7c4f1cebbd7cca6abd7bfdad5c3f19c584ed6bee8cdbde7cbb7d8a286c2c8b8eac1b3e89a5752baaee7b9ace4b3a7e0b1a3d2aaa1dfa69dde9f99d89892d3868bcf8382c56075bc37569b2d37812f218d311f8d33208f2e1f8e301e8d301f8f301e8e31208d2f1d892d1e872d1d872f1c862c1d842b1e82301d802f1a812a1c7f2e1a7a3944d22d3cd1253cd02b3ccf243bcc2339cc213acb253aca253cca9a5558c99383d6bdefcd99a5834639a3644cc693928f464cac5a5ab86465d3c7fccac1f6c9baea693737cfb6dad2c3e9cdbde6723b3cd1c0e8d1c0ecc5918bc1a6d8d2bdead0b8e4bfabc8b0a7dfb7a6d2a96157a97376af777bb493c2aea2dca3a0dea59ddaa698d5868dcd7282ca677ac43e61aa2c3d8731228d3120902c208d2f1f902f208c2b1f8b2f1f8c2d1e8a2e1e8c2d1f89291e852c1d872c1e842d1c832f1f822d1a80271c7e2b1b7c2e19763b3cd32a3dcf293ace273ad0273ccc2239cd2639cb2339cb283ac77661f6e1a97e8c4a52bb98a5c8a0b8c882966e2b298c3d36d4c2f3dac8fbd3c5f8cfc0f48a5357c2b5d6d4c5f6d2c3f4ceb9df8a443dd4b8d0c8aac1c9aec586528dd0c0efccb9ecb8b0dbb19290a093d4a77c88ba99a7b993a7b5a3dba99fd7a19ddba097d68d90d28288cf747fc44a67ae2441892e2388311f902f208f2d218e34258d2f1f8c2e208b2b208b311f882e1f8a2c1f882c1d872b1f832c1d842b1d832f1c7f2f1c7b2c1c792e1b782c1975283ed02a3ad3243ad1243bcf2639cd203ccc2738cc2539cb2937cb223cc5725082b787d6c48eab9b4e61974745bc766ad1bfe5d8c6fcd1c4fbcec4f9c096dc633339c4b7e7d6c4f8d1c0f19f616a9f638ad4c0ebd2bcebc3a6d7935446cdbdefc7b9edc1b3e9b7acdfb9a8d6755d6d8e7a85a48fbd9a90b8b2a1d7a09ad78b92d18187cb777dc14267b031519b2e248533228f2f1f8f34238f2f1f8c2c208b2b1e8e2b208c2b208a321f8b2f1f892b1f892e1e842b1e852e1e812e1d7f2e1c7f2a1b802e1a7b2a1b7a2b1a77333cd1263ccd233bce253ccd283dce283cce253bc92539ca1f3ac92439cb213ac3c881597a3332a14b3acc7a74d9c2f3dcc5f3ddcafdd2c5fbc9b1e16e3b39cfb2b8c4b8e9c7bdf4bb819ac88a6cb8ade3c9bce7cabfedbdacca64354bbdb4eec7b8eebcafe1bbaad2c1b1e9a8a5c4b5a9e08d7899796fa49190ce8b8fd18f8ccf8083ca5a74bb2a4e982e25892f219030218f30218c321f8e2e218c31208a2e1f8b2b1f8b2920872d208a301f8a301e88321e862b1d852c1d83331b81341c80301a7b2b1a7a2b1b752d19762d3dcf2b3cce283ad0213ccb253acf233bcc243acb2838cb2339c82638ca2636c82538c6b3b1fcdbc9fbd0b4e9ddcafddfc8fad7c3f7c6b6f5643437a9665cc1b6ecbdaacf744244cabcebcdc0f4bb7d6d8c5a89c8bae8c0b6e38370808f748bc1abbfc1b7e0beb2ebbdaee6b7ace8a9a2dbb4a6e3aba2dd9c99d78890c4666f992e5996274e9c33248d2e20912f218f2c20922f209030218d2b1f8c3120892c208c2b1f8b2a1f882b2086301f892f1e862c1d822d1c832c1d802c1c7c2a1d7e2b1c7a311a782e19752c1975323cd22d3bd12a3acd243bd0273ccc2538ce203aca2438cc2637c7203ac72337c82836c22536c5825ff4cbbcfcceb9fdd6c5fbcbafdc804a57b37966b8a1b5ac97da6b3b41c8988ac8bdf1d2c0f69b6366baa9c4cdbdefc4b5e9a99ad5a29ed6c5b4e9c2b4efbeb2efb7aae6bda9e4aea6e5999cd69b9cdda298d68985cf6071bd3a5aa730239033228f2e21923322912d1f9030208d30208e321f8a32218f2c20892e1f8b311e87311e852f1e892e1d832c1c83271d812c1c802d1d812d1b7730197a2c197a2c1b7a2d1874323bd12939d0243ccd263acf2639cc2539cc2537ca2a39c92438c52339c32538c32b35c32536c02737c14c42f28849508b5058784349a0655ba97680955861a0574ecfaeadc8bef6c6bcf3c6bbf25e3b45bcaddec2b6edc2b5f0bdb6efb6ade18a61bdbaadebbaafedb4abe8aaa3e1a4a1dba99fe1918ece8c8cd25e6dbe2746a83123932d22922f20903320912f218e2e20902c208b2b1f8d31208a29208b331e8a2c1e882a2085311d882d1f872e1c862f1d842f1d81301a80301b7f2e187d2919792b19752d19762d18742f3cd12c3ace263ace213acb253acc2239cc1e39cb2b3ac92139c82636c82937c62638c42933c02437bd2236bb2536be8b6cddcfbef5957697874d62c4827dcabae8c4bbeec9bff9c9bcf2ad7d987e4b4ebdb1ebbdb0ecc1b5edbcb3efbcb1edb4a8e2b2a8e3b2a9e7b8aae9a7a1e2a39ce18791d57e83cc4464bf31279d2e23952e21922d21912c22902d20912f20902c218e301e8f33208b2b20892e1e8a2e1f89311e892d1e88291f862e1e832d1c852c1e842f1b83271e7d2d1d7c261a7b311b782d19792918762d1974293bce2c3bce253bce243bcc253ccc253acb2537cb2337c72138c62536c62933c52933c32d31c02734be2533bd2931bc2831bb3d32de7d5965b97a72d0bbf2c4b8f1c1b6efc5b9f6c6b3ec8b5058a06e7fb9aee8beafe8bab0ecb3abe6b5acecbbaae8a698cda2a0df9b9dde9195dd9090d57680d3352bb22d26982f269b2f22942d22922e2392322093301f8e2d208e2b1e8f2f1e8a34219132208d2c1f89301d8a321f872f1e882f1e84341e842c1d812e1b82291d812c1b7e2f1a7b2e197b291a772b17792b19742a1972323dcd263bcd223bcb2739cd2737cb2538c82538ca2637c72637c52436c52634c22933c22234bf282fc12634bc2a2fbc2c30b72830b82e2fb5312ebe6671fab2acebc1b3efc3b1f0b8a6e4ab7189b58287b6ace8bdace6b2a8e6b0a7e5afa8e8a39fe29f97d79d98da868ad96271dd2f2bb22e259a3025962d25942d23953123922f219131208f2b20902e208f2b208d2d208c2c1f8e2c1f902e1f8c2d1f8b2a1f882d1f862e1e84321d852c1d862f1d812b1e82321b7f2f1b7f301a7e2b1a792b1a752919772b19763019702e3ccf3638ce2639cd2639cc203bca2539ca2537c72537c82a36c52634c52634c32832c32931bf2b30bf2531bd2632b92731b82a2db82b2eb52c2eb42c2fb32e2fb5342ec13533c7735b8aa3a3e9b4a8e5a8a1e3a19edf9d9adb9e95d9989be4808fdd4d53cf3727af2d27a02d26973223972e25942d239531239931239330219231218f3020912d20912d1f8f30208d31218d2d1e892e1f882b1f8a2e1e882c1f8a281f862f1c862f1e832e1c862d1b812b1d802c1a832a1b802a1c782d1a7a2b1a74291a722f19722818702e38d12a39cb253bc82938cc2a38cc253bc82636c92838c72537c52635c42932c42933c12932be2a30bd2532b92c2eb82c2eb62a2db72e2cb3262eb32b2cb02b2dae2a2db12e2cad2c2cab2b2bad2c2cad2d29ac2b2ba8292cac302ba52d2ca12b29a22f269f2b289b2e269c3225983025982f25943123952e23942f22953121922c20912e20923120902f208d2d1f8e2c208f2f1f8b2c1e8e301e8a33228d2f1e89301f862e21882e1d89341d832f1d7f2e1d822c1c7d2e1b802f1b792d1a772d1a752819732918722e186f2d38ce2c38cb2a39c9283ac82639ca2338cb2836c82835c52238c22932c42536c22432c02b32bd2633bb2731b9292fb7282fb52a2fb32a2eb32c2bb22c2caf2b2dad2f2ab12a2daa322aab2b29ae312ba7302ba43328a32d28a13125a22f24a232269e30269c31279c3123993023993122973322952f23912d21952d23922e22922f21912e209130218e2e1f922f1f8e2c1f8c2e1f892d1f8c301f88321e8b2f1e862d1e872f1d84331b832e1d84301e802d1a822b1c7f301b78271a79301b7b3119742d19722f18712e186d2d39cd2b38cd2639c92a37ca2737c92836c72b35c82a34c72a33c72933c22836c32a32c32a30be2830bc2d2fbb2d2ebb2a2cb82a2db7292db22c2daf2e2bb0292fb02d2aac2d2aab262baa302ba73027a72c2aaa2a27a52c27a52f25a229269d2e269d30249d2b25992f21992f239a3122962c23962d23962f21943023932d22922d228e2e228e2c218d2f218c312090301f8d301f8a2c20892e20872f1d872d1f842a1f84311d852c1e853120872f1c82301d7b311a7c2f1a7c2d1a792f19763018752e197125196e2b1a6b3137cb2938cc2a36ca2a37c52837c72638c72536c42633c42433c02434c12633c02a30bf2a30c02731bd302fb72b2eb5292db62d2db42c2cb22b2bb02d2bad302ab02c2bab2e29ab2f27ac2f28a92b2aa42b28a32c27a22f26a42a26a32c269f2a249e2a259b2a249f3223992e22972d23982c22963021952f2c9c302093321f9232219331218f2f208f2d208e2c1e8d2f1f8b301f8a2c1f892d1e85311e852e1d862c1e872e1d852d1f822d1c812b1d81301b7f2f197b2e1b792d19762f19772c19752d19732f186e2d186d3437cc233ac72839c32635c82438c42a39c22535c12a33be2739bc2433be2733bd2a2fbc2632bc2a2fbb2a32ba272eb62e2cb32b2db3272cb22a2baf2b2cac2d2ab0292bad2d2baa292ba8333ac32e2caa2d2aa62e26a22d28a430259d33249e2e249d2c259a2c249a3222973122962c23992c22952e21962a22923120932d228f2d21912c20902d20902b208c2c208d2b1f8c2a208a30208a2a1f862f1e882e1f872b1e822b1e822c1d83321d802c1c7f2c1b7d32197f321c772b1c782918782c19732a17702f186e2c186b2e37cb2d37c62b39c82839c62d35c22534c02a35bf2934be2631bf2632bd2831be2a30bc2d2fbb2b2fb82c2dba292fb7292eb4282db5292db12a2caf2d2baf2f29ae2e28ad2e28ab282caa292eac2b2ca92e2ba62f26a22e27a12c24a030259b30259c30249c30249a3023982f23952d24963023903221922e22922d22903120902e22902f2092301f8b301f8d2b1f892e1f8b291e86331f942e1f852f1f832e1e832e1c83281e822c1e812d1b802f1c7c2c1a7c2e1c7b2d1b78301d762c19722919722818702a186e26186b3335ca3237c62b34c72837c52336bf2436bf2734c02334bd2831c02c30bb302fb82531b92930b72830b7282fb72e2fb7292db12b2db32d2cb02a2cae2a2baf2b2bad2f2aaa2f29a82a2bac332caa272da72c2ba72926a33326a22c249e2c24982c249d30249a2e249b2d24982d23942e22943024982f22953122953021912820912e238e2d208f2f208b301f8c2e208b291f8b2d1f892f2089311f862c1e872b1d862e1e842e1c832f1e832a1f802c1c7d2a1d7c2e1e792c1a742a19742e19712b197129186f27196c2e18672f38c63138c22e34c32833c22234c0293abd2a32c02731bd2733be2b30ba2830bc2e30b62c2eb92f2fb9292eb72c2eb62c2bb52a2bb32c2bb12a2bb12a2bae2b2cac2c29aa2a2aa92e2ba92e2caa292ba92d2aa72d27a12f25a029269d2f249e3223992d249c2b24992d229b3222963023943124953021932e21933120922f22922d1f8f2f1f8f311f902c1f8d2c1e8a2f20882c1f882e2088281e832e1e832c1f812e1c832d1d80301c81301b7a2f1b762e1a782e1a772b1a743119742b19712b196f2b186d2b186b2a18692e38c72d36c22c33c22933bf2837be2b34bd2b31b92f31be2c30bb2c30b82d30b62d2eba2d2eb52b2eb82f2cb42b2cb62d2bb3272cb4292bb02a2dad2d2bac282bab2d2bac2e27a82f29a82f2aa92c29a82b27a32c25a13125a22f269e2f259e2f249c2f22982e23983023982d23962f24953421952f21952f21912f219232219330208f2d1f8e2f218c2b208e301f892b1f882e1e892d1f872f1e842d1e832b1d822f1c7f2f1c802d1b7c2b1a7c2f1c772e1b7e2e1a7a2e1a752c196f30186d2b18702b186d29186a2c1c6c3735c42f34c32733c02d31be2d33bd2733bb3434bd2a31bc2931b82a2fb92c2fb72d2eb52b2eb7292eb52d2db22a2cb52d2db22a2db02e29b02a2bad2f2aad3129ae252cab2f28a9292ba82c27a73426a42b27a22f25a32e25a02f25a030259d2d249e2e259a2f239931239b2e23972e23942e21933120922e1f933224973120933121902b208d2d208c30208b2e20882e2089301f84302085291e833120832f1f81331d7f2c1d7f301b7b2b1b7b2f1a7e2d19762f1a752a19742d18722b19702c186d29176a2f186b2d18653732c43234c12a34bf2c33bf2f31ba2937b92a30b92f30b82d2fb72b2fb6292fb62a2eb6292fb42c2eb4292db22c2db0312baf2f2cae2f2aaf2e29af2c2dae302aaa2c28ab2f28aa2f29a82d27a72e27a52c26a22d27a53325a22724a32e249c2e239e2e23992f24993224983529982f22992f23942b22923022922e22912c208e2d208c311f8f331e8e2d2089301e872d1f87311f88291c872e1c85301b83321b7d2c1d7d2a1c7e2e1c792f1b772e1b76301b732f19762c1a722c19702b186d2d176c2a196a2b18692b17692f35c33733be2933bc2d31ba2933ba2e30b92c31b72b2fb7322fb7342db62b2eb6292db5322cb22b2cb22d2bb32a2cb02e2cae2d2baf2c2aad2f2aaa2d2aaa3028ac2e29ab3029a92e26a82f26a42b27a43328a22c25a33125a232259f33269d2c259b2b229e3124973623962d23972e24972c219432219631208f311f9232209032218c2f208e2d20892c20892e1f87301f872a20842f1e842b1c84301f822f1d7e2e1b7e321c7e2d1a7b2e1c7f2d1a762b1976291b732c1a6e2d1a702b187028186d2918692a18662b17653635be2e31bd3031bd3131b93130b82b30b83030b83230b92c2eb32c2eb32c2fb32e2cb12f2db1322db12b2caf2c2bb12f29b1312bad2e29aa2f29aa2f28a93128ab3027aa2f28a82e26a52f27a43427a22e27a03126a02e279e2e259a30259d31249c3223992c22973123993523973123953122922d22922f21922f2091311f902d1f8e2f1f8c3020882d20892e1f87311e892f1f84291e81301d85321c7f301c7a2f1c7e2f1b7d331d7b322088301a762d1a702a1b712d197130186d2d186d28186e27186a2618652f17633533ba2d34be2e32ba3030b72e32b72f2fb62c30b72c2fb5312eb32c2eb52c2eb3322db0282cae272dae2e2aad2f29b02f2aae2b2bac3127ad2c28ac2d28a83228a62b2aa42d29a63825a32a27a52e27a62e26a23425a12c259d32249a36259c2e249c3124983423992f22992e23932e23972f22923221942f218f37219030208e31208c2d208a31208c2f1f8b2d2187321e862e1f832d1d832d1e80311f7b2f1d7d291d7a2f1b772e1b772d1c7d2e1a76331a71301a6f2b186f30196b2a18692a186a2d17652717653117653632bc2e32ba3230b73130b6302fb52e30b72e2eb32d2eb32e2eb22e2cb1362bb2322bb7302bac2f2cad362aac2f2bad322aab2c2aab2e27ac3026a72f2da63328a53227a43224a73727a53426a22f269f2d27a02c24a332269a28249d3624983424982f249732239535219833229331229431239732228f32219032208f311f8e31218d30208c34208a2e20852f1e892c1d842e1d81301d7f2f1c822e1e7b341b7a2d1b7a301b783019752d1a762f1a722f1c712d187330186c28196a3118692a176c2b18682f1765281760432fba3331b83031b8322fb7332fb6322db4342db5372db22d2db2352cb1302cae3229ae362cab2e2bab2e2bac312aad3329ab3527a82f2aa73428a73627a73226a53026a73526a33329a53024a33426a22d26a032249f31249c31259833259634239937239238229833219935229533229332219336209237218d32208e33208b35208c34208b3220892c1f86341f84361e82311d832c1e80331b81311d7b301b79321979361a78311b792f1a743019702f19713219742b196f331e7731176e2e17682e18642b17642e1562";
int IMAGE_PIXEL_RATIO = 4; // how many screen pixels each pixel of data should take up;

// functions and stuff below

struct shooterInputs {
  double angle;
  double velocity;
};

double getHeading() {
  return IMU.heading();
}

void calculatePosition() { // get global coordinates from motor speed and IMU heading
  double currentTime = Brain.timer(msec);
  double deltaTime = currentTime - previousTime;
  previousTime = currentTime;

  Brain.Screen.clearScreen();
  Brain.Screen.setCursor(1,1);
  Brain.Screen.print("deltaTime: ");
  Brain.Screen.print(deltaTime);

  double motorForwardAngularSpeed = 0.5 * (motorLeft.velocity(dps) + motorRight.velocity(dps)) / RADIANS_TO_DEGREES; // forwards speed is the average velocity of the two wheels
  double forwardSpeed = motorForwardAngularSpeed * WHEEL_WIDTH/2 / DRIVE_WHEEL_GEAR_RATIO; // get inches/second speed from motor rotation rate

  double motorTurningAngularSpeed = (motorLeft.velocity(dps) - motorRight.velocity(dps)) / RADIANS_TO_DEGREES;
  //double turningSpeed

  double deltaDistance = forwardSpeed * deltaTime; // get distance travelled since last timestep
  double heading = getHeading() / RADIANS_TO_DEGREES; // convert heading to radians because c++ trig uses radians
  position.x += deltaDistance * cos(heading);
  position.y += deltaDistance * sin(heading);
}

void driveForwardDistance(double distance, double speed, bool wait) {
    double motorAngle = DRIVE_WHEEL_GEAR_RATIO * distance / (WHEEL_WIDTH * PI);
    motorLeft.setVelocity(speed, pct);
    motorRight.setVelocity(speed, pct);
    motorLeft.spinFor(forward, motorAngle, rev, false);
    motorRight.spinFor(forward, motorAngle, rev, wait);
}

void driveForwardSpeed(double speed) {
    motorLeft.spin(forward, speed, pct);
    motorRight.spin(forward, speed, pct);
}

void driveTurn(double angle, bool turnOnCenter, bool wait) {
    double rotations = angle/360;
    double wheelTravel = TRACKWIDTH * PI * rotations;
    double motorAngle = DRIVE_WHEEL_GEAR_RATIO * wheelTravel / (WHEEL_WIDTH * PI);
    if (turnOnCenter) {
        motorLeft.spinFor(forward, motorAngle, rev, false);
        motorRight.spinFor(reverse, motorAngle, rev, wait);
    } else {
        if (angle > 0) {
            motorLeft.spinFor(forward, motorAngle*2, rev, false);
        } else {
            motorRight.spinFor(reverse, motorAngle*2, rev, wait);
        }
    }
}

void driveCommand(double forwardPercent, double sidePercent) {
    motorLeft.spin(forward, forwardPercent + sidePercent, pct);
    motorRight.spin(forward, forwardPercent - sidePercent, pct);
}

void driveGlobal(vector3 positionDesired, double angle) { // turns and drives to desired global coordinates, then turns to desired angle
  double headingDesired = 0;
  double heading = 0;
  double headingError = 0;
  double distanceError = 0;
  do {
    double deltaX = positionDesired.x - position.x;
    double deltaY = positionDesired.y - position.y;
    headingDesired = atan2f(deltaX, deltaY) * RADIANS_TO_DEGREES; // convert heading to radians because c++ trig uses radians
    heading = getHeading();
    headingError = headingDesired - heading;
    headingError = fmod((headingError + 540),360) - 180;
    distanceError = sqrtf(deltaX*deltaX + deltaY*deltaY);
    double speedMultiplier = (fabs(headingError)<10);
    driveCommand(distanceError * COORDINATE_GUIDANCE_DISTANCE_GAIN * speedMultiplier, headingError * COORDINATE_GUIDANCE_TURNING_GAIN);
    calculatePosition();
  } while (distanceError > MAX_DISTANCE_FROM_TARGET_NARROW);
  do {
    headingDesired = angle;
    heading = getHeading();
    headingError = headingDesired - heading;
    headingError = fmod((headingError + 540),360) - 180;
    headingError *= COORDINATE_GUIDANCE_TURNING_GAIN;
    driveCommand(0, headingError);
  } while (headingError > MAX_ANGLE_FROM_TARGET);
}

shooterInputs calculateShotAngleAndVelocity(vector3 targetPosition) {
  double distanceX = sqrtf((targetPosition.x - position.x)*(targetPosition.x - position.x) + (targetPosition.y - position.y)*(targetPosition.y - position.y));
  double distanceY = targetPosition.z;
  double desiredVelocityY = sqrt((-0.5*distanceY*G)/(TARGET_POINT_ALONG_TRAJECTORY - TARGET_POINT_ALONG_TRAJECTORY*TARGET_POINT_ALONG_TRAJECTORY));
  double desiredVelocityX = (distanceX*G)/(-desiredVelocityY + ((TARGET_POINT_ALONG_TRAJECTORY > 0.5) ? -1 : 1) * sqrt(desiredVelocityY*desiredVelocityY + 2*distanceY*G));
  double desiredAngle = atan2f(desiredVelocityY, desiredVelocityX);
  double desiredVelocity = sqrt(desiredVelocityX*desiredVelocityX + desiredVelocityY*desiredVelocityY);
  shooterInputs output;
  output.angle = desiredAngle;
  output.velocity = desiredVelocity;
  return output;
}

void resetArmAngle() {
  Brain.Screen.setCursor(1,1);
  Brain.Screen.print(motorArm.current());
  Brain.Screen.setCursor(10,10);
  Brain.Screen.print(motorArm.velocity(rpm));
  motorArm.spin(reverse,30,pct);
  wait(50,msec);
  while (motorArm.current() < 2 || fabs(motorArm.velocity(rpm)) > 5) {
    motorArm.spin(reverse, 30, pct);
  }
  motorArm.stop();
  wait(50,msec);
  motorArm.resetPosition();
  motorArm.spinTo(-ARM_MOTOR_STRIKE_ANGLE, deg, true);
  wait(50,msec);
  motorArm.resetPosition();
}

void resetMotorAngle(motor m, double defaultAngle, vex::directionType dir) {
  Brain.Screen.setCursor(1,1);
  Brain.Screen.print(motorArm.current());
  Brain.Screen.setCursor(10,10);
  Brain.Screen.print(motorArm.velocity(rpm));
  m.spin(dir,30,pct);
  wait(50,msec);
  while (motorArm.current() < 2 || fabs(motorArm.velocity(rpm)) > 5) {
    m.spin(dir, 30, pct);
  }
  m.stop();
  wait(50,msec);
  m.resetPosition();
  m.spinTo(defaultAngle * (dir==forward?1:-1), deg, true);
  wait(50,msec);
  m.resetPosition();
}

void reverseToWall() {
  while (motorLeft.current() < 2 || motorLeft.velocity(rpm) > 5) {
    motorLeft.spin(forward, 10, pct);
    motorRight.spin(forward, 10, pct);
  }
  motorLeft.stop();
  motorRight.stop();
}

void resetIMU() {
  IMU.calibrate();
  while(IMU.isCalibrating()) {
    wait(1, msec);
  }
  position = vector3(2,30,1);
  heading = 0;
  Brain.resetTimer();
}

void setArmAngle(double angle) {
  armAngle = angle;
  motorArm.spinTo(angle*ARM_WHEEL_GEAR_RATIO, deg, true);
}

double getArmAngle() {
  return armAngle;
}

void setShooterDirection(vex::directionType direction) {
  motorShooterL.spin(direction, 100, pct);
  motorShooterR.spin(direction, 100, pct);
}

void setShooterSpeed(double velocity) { // sets shooter motors to spin at the right rate to reach a target speed in inches/second
  double targetAngularSpeed = velocity / (0.5*WHEEL_WIDTH); // shooter uses wheels, so this uses wheel width
  targetAngularSpeed *= 9.549297; // radians to rpm
  targetAngularSpeed /= SHOOTER_WHEEL_GEAR_RATIO;
  targetAngularSpeed *= SHOOTER_SPEED_MULTIPLIER; // accounts for error
  motorShooterL.spin(forward, targetAngularSpeed, rpm);
  motorShooterR.spin(forward, targetAngularSpeed, rpm);
}

vex::vision::object getLargestObject(std::vector<vex::vision::object> objects) {
  int largestXSize = 0;
  vex::vision::object largestObject;
  for (int i = 0; i < objects.size(); i++) {
    if (objects.at(i).width > largestXSize) {
      largestXSize = objects.at(i).width;
      largestObject = objects.at(i);
    }
  }
  return largestObject;
}

Detection getLargestObject(std::vector<Detection> objects) {
  int largestXSize = 0;
  Detection largestObject;
  for (int i = 0; i < objects.size(); i++) {
    if (objects.at(i).width > largestXSize) {
      largestXSize = objects.at(i).width;
      largestObject = objects.at(i);
    }
  }
  return largestObject;
}

int getLargestObjectId(std::vector<Detection> objects) {
  int largestXSize = 0;
  int largestId = 0;
  for (int i = 0; i < objects.size(); i++) {
    if (objects.at(i).width > largestXSize) {
      largestXSize = objects.at(i).width;
      largestId = i;
    }
  }
  return largestId;
}

int getLargestObjectPosX_SingleScan(vex::vision::object object) {
  return object.centerX - CAMERA_PIXEL_WIDTH*0.5; // X is normally based on 0-CAMERA_PIXEL_WIDTH, but this adjusts it so centered = 0
}

int getLargestObjectPosX_MultipleScans(std::vector<Detection> objects) {
  return getLargestObject(objects).centerX - CAMERA_PIXEL_WIDTH*0.5; // X is normally based on 0-CAMERA_PIXEL_WIDTH, but this adjusts it so centered = 0
}

Detection getDetectionClosestTo(std::vector<Detection> objects, int x, int y) {
  double lowestDistance = 9999999;
  Detection closestObject;
  for (int i = 0; i < objects.size(); i++) {
    Detection object = objects.at(i);
    int deltaX = object.centerX - x;
    int deltaY = object.centerY - y;
    double distance = vector3(deltaX, deltaY, 0).magnitude();
    if (distance < lowestDistance) {
      lowestDistance = distance;
      closestObject = object;
    }
  }
  return closestObject;
}

double getObjectDistance(int objectPixelWidth, double objectWidth) {
  double objectFullArcAngle = objectPixelWidth * CAMERA_RADIANS_PER_PIXEL;
  double objectDistance = objectWidth / tanf(objectFullArcAngle);
  //printf("getObjectDistance diagnosis: pixelWidth:%d, objectWidth:%f, objectFullArcAngle:%f, objectDistance:%f, radiansPerPixel:%f, radiansToDegrees:%f\n", objectPixelWidth, objectWidth, objectFullArcAngle, objectDistance, CAMERA_RADIANS_PER_PIXEL, RADIANS_TO_DEGREES);
  return objectDistance;
}

double getLargestObjectDistance_SingleScan(vex::vision::object object, double objectWidth) {
  return getObjectDistance(object.width, objectWidth);
}

double getLargestObjectDistance_MultipleScans(double objectWidth, std::vector<Detection> objects) {
  return getObjectDistance(getLargestObject(objects).width, objectWidth);
}

void printDetection(vex::vision::object obj) {
  printf("X: %d Y: %d WIDTH: %d HEIGHT: %d\n", obj.centerX, obj.centerY, obj.width, obj.height);
}

void printDetection(Detection obj) {
  printf("X: %d Y: %d WIDTH: %d HEIGHT: %d\n", obj.centerX, obj.centerY, obj.width, obj.height);
}

void printDetections(std::vector<vex::vision::object> objects) {
  for (int i = 0; i < objects.size(); i++) {
    vex::vision::object obj = objects.at(i);
    printf("i: %d X: %d Y: %d WIDTH: %d HEIGHT: %d\n", i, obj.centerX, obj.centerY, obj.width, obj.height);
  }
}

void printDetections(std::vector<Detection> objects) {
  for (int i = 0; i < objects.size(); i++) {
    Detection obj = objects.at(i);
    printf("i: %d X: %d Y: %d WIDTH: %d HEIGHT: %d COLOR: %d\n", i, obj.centerX, obj.centerY, obj.width, obj.height, obj.color);
  }
}

Detection convertObject(vex::vision::object object, int color) {
  return Detection(object.centerX, object.centerY, object.width, object.height, color);
}

std::vector<Detection> snapshotMultipleColors(std::vector<int> colors) {
  std::vector<int> ballTypes;
  std::vector<Detection> combinedData;
  for (int c = 0; c < colors.size(); c++) {
    camera.takeSnapshot(colors.at(c));
    //printf("CAMERA DETECTIONS FOR COLOR %d:", colors.at(c));
    //printDetection(camera.largestObject);
    for (int j = 0; j < camera.objectCount; j++) {
      ballTypes.push_back(colors.at(c));
      Detection obj = convertObject(camera.objects[j], colors.at(c));
      //printf("CAMERA DETECTION %d:", j);
      //printDetection(obj);
      combinedData.push_back(obj); 
    }
  }
  BALL_TYPES = ballTypes;
  //printf("CAMERA DETECTIONS FOR ALL COLORS\n");
  //printDetections(combinedData);
  return combinedData;
}

vector3 rotateVectorByAzimuthAndElevation(vector3 v, double azimuth, double elevation) {
  azimuth /= RADIANS_TO_DEGREES;
  elevation /= RADIANS_TO_DEGREES;
  vector3 v2 = vector3(v.x*cos(elevation) - v.z*sin(elevation), v.y, v.z*cos(elevation) + v.x*sin(elevation)); // rotate by elevation
  vector3 v3 = vector3(v2.x*cos(azimuth) + v2.y*sin(azimuth), v2.y*cos(azimuth) - v2.x*sin(azimuth), v2.z); // rotate by azimuth
  return v3;
}

vector3 getDetectionPositionAsBall(vex::vision::object obj) { // get the worldspace position
  double distance = getObjectDistance(obj.width, WIDTH_BALL);
  distance += 0.5*WIDTH_BALL;
  double azimuth = (obj.centerX - 0.5*CAMERA_PIXEL_WIDTH) * CAMERA_DEGREES_PER_PIXEL;
  double elevation = (obj.centerY - 0.5*CAMERA_PIXEL_HEIGHT) * CAMERA_DEGREES_PER_PIXEL;
  vector3 ballPosition_TurretspaceRelativeToCamera = rotateVectorByAzimuthAndElevation(vector3(distance, 0, 0), azimuth, elevation);
  vector3 ballPosition_TurretspaceRelativeToGimbal = ballPosition_TurretspaceRelativeToCamera.difference(CAMERA_RELATIVE_TO_TURRET_GIMBAL_POSITION);
  vector3 ballPosition_Vehiclespace = rotateVectorByAzimuthAndElevation(ballPosition_TurretspaceRelativeToGimbal, 0, -getArmAngle()).difference(TURRET_GIMBAL_POSITION);
  vector3 ballPosition = rotateVectorByAzimuthAndElevation(ballPosition_Vehiclespace, -getHeading(), 0).add(position);
  return ballPosition;
}

bool ballPosition_InPlayingSpace(vector3 v) {
  vector3 buffer = vector3(10, 10, 2); // Amount past the course dimensions we are willing to take
  if (v.x < -buffer.x) { return false;}
  if (v.x > 74 + buffer.x) { return false; }
  if (fabs(v.z - 0.5*WIDTH_BALL) > buffer.z) { return false; }
  if (fabs(v.y) > 50 + buffer.y) { return false; }
  return true;
}

bool detectionAsBall_InPlayingSpace(vex::vision::object obj) {
  return ballPosition_InPlayingSpace(getDetectionPositionAsBall(obj));
}

std::vector<vex::vision::object> filterDetectionsForValidBalls(std::vector<vex::vision::object> input) {
  std::vector<vex::vision::object> validBalls;
  for (int i = 0; i < input.size(); i++) {
    if (detectionAsBall_InPlayingSpace(input.at(i))) {
      validBalls.push_back(input.at(i));
    }
  }
  return validBalls;
}

void getPlayingSide() {
  std::vector<Detection> yellowIndicatorDetections = snapshotMultipleColors(std::vector<int>(YELLOW_INDICATOR));
  std::vector<Detection> greenIndicatorDetections = snapshotMultipleColors(std::vector<int>(GREEN_INDICATOR));
  Detection yellowIndicator = getDetectionClosestTo(yellowIndicatorDetections, 0, 0);
  Detection greenIndicator = getDetectionClosestTo(yellowIndicatorDetections, 0, 0);
  PLAYING_SIDE = (yellowIndicator.centerX > greenIndicator.centerX) ? -1 : 1;
}

void applyPlayingSide() {
  RED_HOOP_POSITION.mirror(PLAYING_SIDE);
  BLUE_HOOP_POSITION.mirror(PLAYING_SIDE);
  CENTER_HOOP_POSITION.mirror(PLAYING_SIDE);
  YELLOW_BALL_HOLDER_POSITION.mirror(PLAYING_SIDE);
}

void printData(std::vector<int> data) {
  for (int i = 0; i < data.size(); i++) {
    printf("DATAPOINT %d: %d", i, data.at(i));
  }
}

void yellowBallRun() { // The part of the auto script that runs towards the yellow ball at the beginning of the match
  // Shooter should already be set to intake mode from the setup phase.
  int ballDistance;
  // Angle turret to yellow-ball-grabbing height
  //[ARM NOT ATTACHED] setArmAngle(15);
  // Align camera with largest yellow target and slam the throttle. Get to the yellow ball as fast as possible for the easy 10 points.
  do {
    camera.takeSnapshot(YELLOW_BALL);
    ballDistance = getLargestObjectDistance_SingleScan(camera.largestObject, WIDTH_BALL);
    double error = getLargestObjectPosX_SingleScan(camera.largestObject) * TURNING_GAIN_FINE;
    driveCommand(70, error);
    printf("Ball distance: %d Error: %f\n", ballDistance, error);
    wait(10, msec);
  } while (ballDistance > 5);
  // Reverse to around the starting position.
  driveForwardDistance(5, 100, true);
  driveForwardDistance(-20, 100, true);
}

void ballSearch_GrabFoundBall() { // A preset motion that moves towards balls to pick them up
  driveForwardDistance(5, 50, true);
  driveForwardDistance(-5, 50, true);
}

void ballSearch_GuidanceLoop(std::vector<Detection> ballsDetected) { // The part of the ball-searching script that loops
  Detection ball = getLargestObject(ballsDetected);
  double distance = getLargestObjectDistance_MultipleScans(WIDTH_BALL, ballsDetected);
  //   a. Check FOV for balls. If ball count is below the threshold, reverse/look around until one is found.
  //if ((ballsDetected.size() > 0 || distance > 30) && !timeLimited) {
  if (ballsDetected.size() == 0) {
    driveCommand(0, 20);
  } else {
    //   b. Align to ball, move towards ball until at edge of camera's visual range
    double error = getLargestObjectPosX_MultipleScans(ballsDetected) * TURNING_GAIN_BROAD;
    driveCommand(30, error);
    printf(".");
    if (distance < BALL_GRAB_DISTANCE) {
      //   c. Preset ball-grab sequence since now blind
      printf("Adding value %d to ballsHeld", ball.color);
      ballsHeld.push_back(ball.color);
      ballSearch_GrabFoundBall();
      printf("Ball grabbed");
      //   d. Keep track of held balls with a list
    }
  }
}

void searchForBalls() { // The part of the auto script that searches for balls when it needs more
  // Rev shooter to full/partial speed reverse
  setShooterDirection(forward);
  // threshold = number of balls we need to have loaded before we start shooting them.
  std::vector<int> ballTypes = {RED_BALL, BLUE_BALL, YELLOW_BALL};
  std::vector<Detection> ballsDetected = snapshotMultipleColors(ballTypes);

  int BALL_THRESHOLD = 2;
  // While >0 balls seen, or ball count is below the threshold:
  while (ballsDetected.size() > 0 || ballsHeld.size() < BALL_THRESHOLD) {
    ballSearch_GuidanceLoop(ballsDetected);
    ballsDetected = snapshotMultipleColors(ballTypes);
    wait(10, msec);
  }
}

int getTargetHoop(int ball) { // Get the hoop we should aim to based on the current ball and auto vs. teleop period.
  if (inTeleopPeriod) {
    switch(ball) {
      case RED_BALL: return TARGET_RED_HOOP;
      case BLUE_BALL: return TARGET_CENTER_HOOP;
      case YELLOW_BALL: return TARGET_CENTER_HOOP;
      default: return -2;
    }
  } else {
    switch (ball) {
      case RED_BALL: return TARGET_RED_HOOP;
      case BLUE_BALL: return TARGET_BLUE_HOOP;
      case YELLOW_BALL: return TARGET_CENTER_AND_WAIT;
      default: return -2;
    }
  }
}

vector3 getTargetPosition(int target) {
  switch(target) {
    case TARGET_CENTER_AND_WAIT: return CENTER_HOOP_POSITION;
    case TARGET_RED_HOOP: return RED_HOOP_POSITION;
    case TARGET_BLUE_HOOP: return BLUE_HOOP_POSITION;
    case TARGET_CENTER_HOOP: return CENTER_HOOP_POSITION;
    case TARGET_YELLOW_BALL_HOLDER: return YELLOW_BALL_HOLDER_POSITION;
    default: return vector3(0,0,0);
  }
}

void pushBall() {
  double PUSH_BALL_ANGLE = 45; // the angle the pusher motor needs to rotate to push one ball out
  motorPusher.spinFor(PUSH_BALL_ANGLE, deg);
}

void resetPusherPosition() {
  double PUSHER_DEFAULT_ANGLE = 15; // the angle the pusher motor rests at
  motorPusher.spinTo(PUSHER_DEFAULT_ANGLE, deg, true);
}

void shootBalls() {
  // While >0 balls in clip:
  while (ballsHeld.size() > 0) {
    int ball = ballsHeld.at(ballsHeld.size()-1);
    int target = getTargetHoop(ball);
    if (target == TARGET_CENTER_AND_WAIT && !timeLimited) {
      return;
    }
    // a. Drive to a known hoop position
    // b. Align to hoop
    vector3 targetPosition = getTargetPosition(target);
    vector3 deltaPosition = targetPosition.difference(position);
    double angleToTarget = atan2f(deltaPosition.x, deltaPosition.y) * RADIANS_TO_DEGREES;
    if (position.difference(vector3(0,20,0)).magnitude() > MAX_DISTANCE_FROM_TARGET_BROAD) {
      driveGlobal(vector3(0, 20, 0), angleToTarget);
    }
    // c. Calculate hoop distance based off of vertical+horizontal size in camera's FOV and known vertical distance
    // d. Calculate necessary turret angle + shooter spinrate based off of math
    deltaPosition = targetPosition.difference(position);
    shooterInputs inputs = calculateShotAngleAndVelocity(deltaPosition);
    // e. Adjust bot angle + turret angle + shooter spinrate until within a margin of error
    setArmAngle(inputs.angle);
    setShooterSpeed(inputs.velocity);
    wait(100, msec);
    // f. Push one ball out with the piston system (the piston positions are preset/known, no calculations or readings needed to see if the ball is shot out)
    pushBall();
  }
  resetPusherPosition();
}

unsigned long hex2dec(char hexChar) // this function is not mine
{
    std::string hex(1, hexChar);
    unsigned long result = 0;
    for (int i=0; i<hex.length(); i++) {
        if (hex[i]>=48 && hex[i]<=57)
        {
            result += (hex[i]-48)*pow(16,hex.length()-i-1);
        } else if (hex[i]>=65 && hex[i]<=70) {
            result += (hex[i]-55)*pow(16,hex.length( )-i-1);
        } else if (hex[i]>=97 && hex[i]<=102) {
            result += (hex[i]-87)*pow(16,hex.length()-i-1);
        }
    }
    return result;
}

double getHueFromRGB(std::string inputHex) { // algorithm from someone on stackExchange idk
  double red = 16*(int)hex2dec(inputHex[1]) + (int)hex2dec(inputHex[2]);
  double green = 16*(int)hex2dec(inputHex[3]) + (int)hex2dec(inputHex[4]);
  double blue = 16*(int)hex2dec(inputHex[5]) + (int)hex2dec(inputHex[6]);
  red /= 255;
  green /= 255;
  blue /= 255;
  double max;
  if (red > green && red > blue) {max = red;}
  else if (green > red && green > blue) {max = green;}
  else {max = blue;}
  double min;
  if (red < green && red < blue) {min = red;}
  else if (green < red && green < blue) {min = green;}
  else {min = blue;}
  double hue;
  if (max == red) {hue = (green-blue);}
  else if (max == green) {hue = 2 + (blue-red);}
  else {hue = 4 + (red-green);}
  hue *= 60/(max-min);
  if (hue < 0) {hue += 360;}
  return hue;
}

char* intToChar(int value) {
  char* buffer = new char[10];
  sprintf(buffer, "%d", value);
  return buffer;
}

void printImage() {
  for (int x = 0; x < 480; x++) {
    for (int y = 0; y < 272; y++) {
      int i = (272/IMAGE_PIXEL_RATIO)*(x/IMAGE_PIXEL_RATIO) + (y/IMAGE_PIXEL_RATIO);
      i *= 6;
      /*char* hexColor = "#      ";
      for (int j = 0; j < 6; j++) {
        hexColor[j+1] = image[i+j];
      }*/
      std::string hexColor = "#" + image.substr(i, i+6);
      //hexColor = "#ffffff";
      int hueColor = fmod(i,360);
      if (hueColor < 120) {
        hueColor = 0;
      } else {
        hueColor = 180;
      }
      hueColor = getHueFromRGB(hexColor);
      Brain.Screen.setPenColor(hueColor);
      Brain.Screen.drawPixel(x, y);
      printf("%s",hexColor.c_str());
      printf("%s\n",intToChar(hueColor));
    }
  }
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the V5 has been powered on and        */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/



void pre_auton(void) {

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
  //
  // uses a physical-contact position resetting technique
  resetArmAngle();
  // shooter should be on intake mode at the beginning
  setShooterDirection(reverse);
  // calibrate the position + rotation by reversing back to the wall and resetting the IMU's position
  reverseToWall();
  resetIMU();
  getPlayingSide();
  printf("Playing side: %d", PLAYING_SIDE);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void autonomous(void) {
  // ..........................................................................
  // Insert autonomous user code here.
  // ..........................................................................

  // ..........................................................................
  // What I'm thinking for the auto loop:
  //
  //
  // 
  while(1) {
    // PART 1: YELLOW BALL RUN
    yellowBallRun();

    // PART 2: SEARCH FOR BALLS
    searchForBalls();
    // PART 3: SHOOT BALLS

    shootBalls();
    // Angle turret to some positive value like +30deg
    // ..........................................................................
  }

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void usercontrol(void) {
  // User control code here, inside the loop
  while (1) {
    // This is the main execution loop for the user control program.
    // Each time through the loop your program should update motor + servo
    // values based on feedback from the joysticks.

    // ........................................................................
    // Insert user code here. This is where you use the joystick values to
    // update your motors, etc.
    // ........................................................................

    // ..........................................................................
    // What I'm thinking for the manual loop:
    //
    // Either the below or just a continutation of auto control
    //
    // LEFT JOYSTICK
    //   X+Y: Directional control of the robot while not performing another action.
    //
    // LEFT BUMPERS
    //   Top: Set robot to shooting mode. Robot will force-enter this mode if time is low or ball storage is full.
    //   Bottom: Set robot to intake mode.
    // ..........................................................................

    wait(20, msec); // Sleep the task for a short amount of time to
                    // prevent wasted resources.
  }
}

//
// Main will set up the competition functions and callbacks.
//
int main() {
  /* ---------- REAL CODE FOR THE COMPETITION ---------- */
  /*// Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }*/

  /* ---------- CODE THAT TESTS FUNCTIONS ---------- */
  /* ---------- it doesnt work because c++  disables exceptions by default and idk how to activate them ----------*/
  Brain.Screen.setCursor(1,1);
  /*Brain.Screen.print("resetArmAngle(); "); try {resetArmAngle(); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("setArmAngle(15); "); try {setArmAngle(15); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("setShooterDirection(forward); "); try {setShooterDirection(forward); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("camera.takeSnapshot(RED_BALL); "); try {camera.takeSnapshot(RED_BALL); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("getLargestObjectPosX(); "); try {getLargestObjectPosX(); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("getLargestObjectDistance_SingleScan(WIDTH_BALL); "); try {getLargestObjectDistance_SingleScan(WIDTH_BALL); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("yellowBallRun(); "); try {yellowBallRun(); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  Brain.Screen.print("printImage(); "); try {printImage(); Brain.Screen.print("succeeded\n");} catch (const std::exception& e) {Brain.Screen.print("failed\n");} wait(1000, msec);
  */

 /* ---------- CODE THAT TESTS FUNCTIONS LAZILY ---------- */
 int printValue = 0;
  //resetArmAngle(); // Good!
  //Brain.Screen.print("resetArmAngle() OK\n");
  //wait(3, sec);
  //setArmAngle(15); // Good!
  //Brain.Screen.print("setArmAngle(15) OK\n");
  //wait(3, sec);
  //setShooterSpeed(193); // Good!
  //setShooterDirection(forward);
  //Brain.Screen.print("setShooterDirection(forward) OK\n");
  //wait(3, sec);
  wait(5, sec);
  getPlayingSide();
  printf("------------------Playing side: %d\n", PLAYING_SIDE);
  wait(1, sec);
  //while(true) {
  //camera.takeSnapshot(RED_BALL);
  //printf("camera.takeSnapshot(RED_BALL) OK\n");
  //Brain.Screen.newLine();
  //printDetection(camera.largestObject);
  //printf("Number of detections: %d\n", camera.objectCount);
  //printf("%d ", getLargestObjectPosX_SingleScan(camera.largestObject));
  //printf("getLargestObjectPosX_SingleScan() OK\n");
  //wait(1, msec);
  //printf("%f ", getLargestObjectDistance_SingleScan(camera.largestObject, WIDTH_BALL));
  //printf("getLargestObjectDistance_SingleScan(WIDTH_BALL) OK (with width of %d)\n", camera.largestObject.width);
  //wait(3, sec);
  //printf("--------------------------------------\n");
  //}
  //std::vector<int> searchValues = {RED_BALL, BLUE_BALL, YELLOW_BALL};
  //std::vector<Detection> multipleDetection = snapshotMultipleColors(searchValues);
  //printf("snapshotMultipleColors({RED_BALL, BLUE_BALL, YELLOW_BALL}) OK\n");
  //printDetections(multipleDetection);
  //printf("g");
  //wait(3, sec);
  //printf("%d ", getLargestObjectPosX_MultipleScans(multipleDetection));
  //printf("getLargestObjectPosX_MultipleScans(multipleDetection) OK\n");
  //wait(3, sec);
  //printf("%f ", getLargestObjectDistance_MultipleScans(WIDTH_BALL, multipleDetection));
  //printf("getLargestObjectDistance_MultipleScans(WIDTH_BALL, multipleDetection) OK\n");
  //wait(3, sec);
  //yellowBallRun();
  //printf("yellowBallRun() OK\n");
  //wait(3, sec);
  searchForBalls();
  printf("searchForBalls() OK\n");
  //wait(3, sec);
  //printImage(); // Bad
  //printf("printImage() OK\n");
}
